/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "../final/game.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_WCLOCKS
#define CEU_STACK_CLEAR
#define CEU_EXTS
#define CEU_GOTO
#define CEU_VECTOR
#define CEU_INTS
#define CEU_VECTOR_MALLOC
#define CEU_RET
#define CEU_CLEAR
#define CEU_ORGS
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s16 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 9

#ifndef _CEU_SYS_H
#define _CEU_SYS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_lua_concat(l,n)                  lua_concat(l,n)
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushboolean(l,v)             lua_pushboolean(l,v)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlstring(l,v,n)           lua_pushlstring(l,v,n)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex_internal;
    CEU_THREADS_MUTEX_T threads_mutex_external;
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       is_aborted;
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int ceu_go_all (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void ceu_sys_go (tceu_app* app, int evt, void* evtp);

#endif  /* _CEU_OS_H */


#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_SYS_H
#define _CEU_SYS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_lua_concat(l,n)                  lua_concat(l,n)
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushboolean(l,v)             lua_pushboolean(l,v)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlstring(l,v,n)           lua_pushlstring(l,v,n)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex_internal;
    CEU_THREADS_MUTEX_T threads_mutex_external;
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       is_aborted;
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int ceu_go_all (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void ceu_sys_go (tceu_app* app, int evt, void* evtp);

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len, int force);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_copy_buffer (tceu_vector* to, int idx, const byte* fr, int n, int force);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#endif


        /* CEU_ISR_ */
#define CEU_IN__NONE 0
#define CEU_IN__ORG 255
#define CEU_IN__ORG_PSED 254
#define CEU_IN__CLEAR 253
#define CEU_IN__ok_killed 252
#define CEU_IN__INIT 251
#define CEU_IN__ASYNC 250
#define CEU_IN__THREAD 249
#define CEU_IN__WCLOCK 248
#define CEU_IN_SDL_REDRAW 247
#define CEU_IN_SDL_QUIT 246
#define CEU_IN_SDL_DT 245
#define CEU_IN_SDL_KEYDOWN 244
#define CEU_IN_SDL_KEYUP 243
#define CEU_IN_SDL_MOUSEBUTTONDOWN 242
#define CEU_IN_higher CEU_IN__INIT
#define CEU_IN_lower 242
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_SDL_RenderPresent
#define CEU_FUN_time
#define CEU_FUN_SDL_Init
#define CEU_FUN_srand
#define CEU_FUN_SDL_RenderFillRect
#define CEU_FUN_SDL_Rect
#define CEU_FUN_exit
#define CEU_FUN_SDL_SetRenderDrawColor
#define CEU_FUN_SDL_CreateRenderer
#define CEU_FUN_SDL_CreateWindow
#define CEU_FUN_SDL_DestroyWindow
#define CEU_FUN_SDL_DestroyRenderer
#define CEU_FUN_SDL_Quit
#define CEU_FUN_printf
#define CEU_FUN_ceu_out_assert
#define CEU_FUN_SDL_GetError
   /* CEU_FUN_ */
typedef struct {
	SDL_Rect _1;
	int _2;
} tceu__SDL_Rect__int;
typedef struct {
	s32 _1;
} tceu__s32;
typedef struct {
	int _1;
} tceu__int;
typedef struct {
	int _1;
	int _2;
} tceu__int__int;
typedef struct {
	u8 _1;
	u8 _2;
	u8 _3;
	u8 _4;
} tceu__u8__u8__u8__u8;
typedef struct {
	SDL_KeyboardEvent* _1;
} tceu__SDL_KeyboardEvent_;
typedef struct {
	SDL_MouseButtonEvent* _1;
} tceu__SDL_MouseButtonEvent_;
typedef struct {
	int _1;
	int _2;
	int _3;
	int _4;
} tceu__int__int__int__int;


/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */


typedef                           struct { /* BLOCK ln=4 */
                            u8 r;
                            u8 g;
                            u8 b;
                            u8 a;
                          }  CEU_SDL_Color;


typedef                           struct { /* BLOCK ln=11 */
                            int x;
                            int y;
                          }  CEU_SDL_Point;


typedef                           struct { /* BLOCK ln=16 */
                            int x;
                            int y;
                            int w;
                            int h;
                          }  CEU_SDL_Rect;

enum {
CEU_NONE1592,
CEU__OPTION___SDL_WINDOW__REF_NIL,
CEU__OPTION___SDL_WINDOW__REF_SOME
};

typedef struct CEU__Option___SDL_Window__ref {
    u8 tag;
    union {
                                            struct { /* BLOCK ln=186 */
                                            } NIL;
                                            struct { /* BLOCK ln=186 */
                                              SDL_Window* v;
                                            } SOME;
    };
}
 CEU__Option___SDL_Window__ref;

enum {
CEU_NONE1598,
CEU__OPTION___SDL_RENDERER__REF_NIL,
CEU__OPTION___SDL_RENDERER__REF_SOME
};

typedef struct CEU__Option___SDL_Renderer__ref {
    u8 tag;
    union {
                                            struct { /* BLOCK ln=199 */
                                            } NIL;
                                            struct { /* BLOCK ln=199 */
                                              SDL_Renderer* v;
                                            } SOME;
    };
}
 CEU__Option___SDL_Renderer__ref;

typedef struct CEU_SDL {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 5 ];
                          struct { /* BLOCK ln=159 */
                            int flags;
                            int w;
                            int h;
                            CEU_VECTOR_DCL(title,char,0)
;
                            SDL_Window* win;
                            SDL_Renderer* ren;
                            union {
                                union {
                                };
                              struct { /* BLOCK ln=159 */
                                union {
                                  struct { /* BLOCK ln=170 */
                                  u8 __fin_187_1: 1;
                                  u8 __fin_187_2: 1;
                                  u8 __fin_187_3: 1;
                                    CEU__Option___SDL_Renderer__ref ren_;
                                    CEU__Option___SDL_Window__ref win_;
                                    union {
                                        struct { /* BLOCK ln=171 */
                                          union {
                                          };
                                        } ;
                                      union {
                                      };
                                        struct { /* BLOCK ln=179 */
                                          union {
                                          };
                                        } ;
                                          struct { /* BLOCK ln=183 */
                                            union {
                                            };
                                          } ;
                                      union {
                                              union {
                                              };
                                              union {
                                              };
                                      };
                                          struct { /* BLOCK ln=195 */
                                            union {
                                            };
                                          } ;
                                      union {
                                              union {
                                              };
                                              union {
                                              };
                                      };
                                          struct { /* BLOCK ln=203 */
                                            union {
                                            };
                                          } ;
                                    };
                                  } ;
                                };
                              } ;
                            };
                          } ;

} CEU_SDL;


void CEU_SDL_build (tceu_app* _ceu_app, CEU_SDL* __ceu_this, int flags, int w, int h, char* title)
;
void CEU_SDL_build (tceu_app* _ceu_app, CEU_SDL* __ceu_this, int flags, int w, int h, char* title)
;



typedef struct CEU_Player {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 8 ];
                          struct { /* BLOCK ln=34 */
                            SDL_Renderer* ren;
                            int x;
                            int y;
                            SDL_Rect r;
                            union {
                                union {
                                };
                              struct { /* BLOCK ln=34 */
                                int _ret_20;
                                union {
                                    struct { /* BLOCK ln=41 */
                                      int life;
                                      int vx;
                                      int vy;
                                      union {
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=45 */
                                            union {
                                              struct { /* BLOCK ln=45 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=46 */
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=51 */
                                            union {
                                              struct {
                                                struct { /* BLOCK ln=52 */
                                                  union {
                                                    struct { /* BLOCK ln=52 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=53 */
                                                            SDL_KeyboardEvent* key_25;
                                                            union {
                                                              union {
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=54 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=56 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=60 */
                                                  union {
                                                    struct { /* BLOCK ln=60 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=61 */
                                                            SDL_KeyboardEvent* key_26;
                                                            union {
                                                              union {
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=62 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=64 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=68 */
                                                  union {
                                                    struct { /* BLOCK ln=68 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=69 */
                                                            SDL_KeyboardEvent* key_27;
                                                            union {
                                                              union {
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=70 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=72 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=77 */
                                                  union {
                                                    struct { /* BLOCK ln=77 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=78 */
                                                            SDL_KeyboardEvent* key_28;
                                                            union {
                                                              union {
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=79 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                              union {
                                                                struct { /* BLOCK ln=81 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      union {
                                                                      };
                                                                  };
                                                                } ;
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=88 */
                                            union {
                                              struct { /* BLOCK ln=88 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=89 */
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=96 */
                                            union {
                                              struct { /* BLOCK ln=96 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=97 */
                                                      union {
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=102 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;

} CEU_Player;




typedef struct CEU_Main {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 9 ];
    struct { /* BLOCK ln=1 */
      union {
          union {
          };
        struct { /* BLOCK ln=1 */
          int _ret_0;
          union {
              struct { /* BLOCK ln=1 */
                union {
                  union {
                    struct { /* BLOCK ln=1 */
                    u8 __fin_639_1: 1;
                    u8 __fin_639_2: 1;
                      CEU__Option___SDL_Window__ref window;
                      CEU__Option___SDL_Renderer__ref renderer;
                      union {
                        union {
                        };
                            union {
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                            };
                            union {
                              union {
                              };
                              union {
                              };
                            };
                            union {
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                            };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                            struct { /* BLOCK ln=20 */
                              union {
                              };
                            } ;
                        union {
                        };
                            struct { /* BLOCK ln=27 */
                              union {
                              };
                            } ;
                        struct {
                          struct { /* BLOCK ln=117 */
                            union {
                              union {
                              };
                            };
                          } ;
                          struct { /* BLOCK ln=119 */
                            union {
                              struct { /* BLOCK ln=119 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=120 */
                                      union {
                                        union {
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=128 */
                            struct CEU_Player p_15;
                            union {
                                  struct { /* BLOCK ln=129 */
                                    union {
                                    };
                                  } ;
                              struct { /* BLOCK ln=131 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=132 */
                                      union {
                                        union {
                                            s32 __wclk_1511;
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=136 */
                            union {
                              struct { /* BLOCK ln=136 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=137 */
                                      union {
                                        union {
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                        };
                        union {
                        };
                      };
                    } ;
                  };
                };
              } ;
          };
        } ;
      };
    } ;

} CEU_Main;






#endif

#ifndef _CEU_SYS_H
#define _CEU_SYS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_lua_concat(l,n)                  lua_concat(l,n)
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushboolean(l,v)             lua_pushboolean(l,v)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlstring(l,v,n)           lua_pushlstring(l,v,n)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex_internal;
    CEU_THREADS_MUTEX_T threads_mutex_external;
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       is_aborted;
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int ceu_go_all (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void ceu_sys_go (tceu_app* app, int evt, void* evtp);

#endif  /* _CEU_OS_H */

#ifndef _CEU_SYS_H
#define _CEU_SYS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_lua_concat(l,n)                  lua_concat(l,n)
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushboolean(l,v)             lua_pushboolean(l,v)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlstring(l,v,n)           lua_pushlstring(l,v,n)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex_internal;
    CEU_THREADS_MUTEX_T threads_mutex_external;
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       is_aborted;
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int ceu_go_all (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void ceu_sys_go (tceu_app* app, int evt, void* evtp);

#endif  /* _CEU_OS_H */


#ifdef CEU_ISRS
    #ifndef ceu_out_isr_on
        #error "Missing definition for macro \"ceu_out_isr_on\"."
    #endif
    #ifndef ceu_out_isr_off
        #error "Missing definition for macro \"ceu_out_isr_off\"."
    #endif
    #ifndef ceu_out_isr_attach
        #error "Missing definition for macro \"ceu_out_isr_attach\"."
    #endif
    #ifndef ceu_out_isr_detach
        #error "Missing definition for macro \"ceu_out_isr_detach\"."
    #endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_SYS_H
#define _CEU_SYS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_lua_concat(l,n)                  lua_concat(l,n)
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushboolean(l,v)             lua_pushboolean(l,v)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlstring(l,v,n)           lua_pushlstring(l,v,n)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex_internal;
    CEU_THREADS_MUTEX_T threads_mutex_external;
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       is_aborted;
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int ceu_go_all (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void ceu_sys_go (tceu_app* app, int evt, void* evtp);

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len, int force);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_copy_buffer (tceu_vector* to, int idx, const byte* fr, int n, int force);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

int ceu_vector_setlen (tceu_vector* vector, int nxt, int force) {
    if (nxt<=vector->nxt || force)
    {
#ifdef CEU_VECTOR_MALLOC
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
        else
#endif
        {
            if (nxt > vector->max) {
                return 0;
            }
        }

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }
    } else {
        /* can only decrease vector->nxt */
        return 0;
    }

    vector->nxt = nxt;
    return 1;
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    return ceu_vector_copy_buffer(to,
                                  ceu_vector_getlen(to),
                                  fr->mem,
                                  ceu_vector_getlen(fr)*fr->unit,
                                  1);
}

int ceu_vector_copy_buffer (tceu_vector* to, int idx, const byte* fr, int n, int force) {
    ceu_out_assert_msg((n % to->unit) == 0, "bug found");
    int len = idx + n/to->unit;
    if (ceu_vector_getlen(to)<len && !ceu_vector_setlen(to,len,force)) {
        return 0;
    } else {
        memcpy(&to->mem[idx*to->unit], fr, n);
        return 1;
    }
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);

/**********************************************************************/

void ceu_sys_org_init (tceu_org* org, int n, int lbl,
                       int cls, int isDyn,
                       tceu_org* parent_org, tceu_ntrl parent_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));
    org->trls[0].lbl = lbl;

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    org->cls = cls;
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
    org->isAlive = 1;
#endif

#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    org->parent_org = parent_org;
    org->parent_trl = parent_trl;
    org->nxt = NULL;
    if (parent_org != NULL) {
        tceu_trl* trl = &parent_org->trls[parent_trl];
        if (trl == NULL) {
            org->prv = NULL; /* main class */
        } else {
            /* re-link */
            if (trl->org == NULL) {
                trl->org = org;
            } else {
                tceu_org* last = trl->org->prv;
                last->nxt = org;
                org->prv = last;
            }
            trl->org->prv = org;
        }
    }

#ifdef CEU_ORGS_AWAIT
    org->ret = 0;   /* TODO: still required? */
#endif

#endif  /* CEU_ORGS */
}

#ifdef CEU_ORGS

static void ceu_sys_org_free (tceu_app* app, tceu_org* org)
{
    /* TODO: try to not depend on this and remove this field */
    if (org->isAlive) {
        org->isAlive = 0;
    } else {
        return;
    }

    /* re-link PRV <-> NXT */
    /* relink also static orgs for efficiency */
    tceu_trl* trl = &org->parent_org->trls[org->parent_trl];
    if (trl->org == org) {
        trl->org = org->nxt;        /* subst 1st org */
    } else {
        org->prv->nxt = org->nxt;
    }
    if (org->nxt == NULL) {
        if (trl->org != NULL) {
            trl->org->prv = org->prv;   /* subst lst org */
        }
    } else {
        org->nxt->prv = org->prv;
    }

#ifdef CEU_ORGS_NEWS
    /* free */
    if (org->isDyn) {
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free(&org->pool->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->pool.queue == NULL) {
            org->nxt = app->tofree;
            app->tofree = org;
        } else {
            ceu_pool_free(&org->pool->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        org->nxt = app->tofree;
        app->tofree = org;
#endif
    }
#endif
}

/*
 * Checks if "me" is cleared due to a clear in "clr_org".
 * ;
 */
static int ceu_org_is_cleared (tceu_org* me, tceu_org* clr_org,
                               tceu_ntrl clr_t1, tceu_ntrl clr_t2)
{
    if (me == clr_org) {
        return (clr_t1==0 && clr_t2==me->n-1);
    }

    tceu_org* cur_org;
    for (cur_org=me; cur_org!=NULL; cur_org=cur_org->parent_org) {
        if (cur_org->parent_org == clr_org) {
            if (cur_org->parent_trl>=clr_t1 && cur_org->parent_trl<=clr_t2) {
                return 1;
            }
        }
    }
    return 0;
}

#endif  /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_STACK_CLEAR
void ceu_sys_stack_dump (tceu_stk* stk) {
    printf(">>> STACK DUMP:\n");
    for (; stk!=NULL; stk=stk->down) {
        printf("\t[%p] down=%p org=%p trls=[%d,%d]\n",
            stk, stk->down, stk->org, stk->trl1, stk->trl2);
    }
}

/*
 * Trails [t1,t2] of "org" are dyeing.
 * Traverse the stack to see if a pending call is enclosed by this range.
 * If so, the whole stack has to unwind and continue from what we pass in 
 * lbl_or_org.
 */
void ceu_sys_stack_clear (tceu_stk* stk, tceu_org* org,
                          tceu_ntrl t1, tceu_ntrl t2) {
    for (; stk->down!=NULL; stk=stk->down) {
        if (!stk->is_alive) {
            continue;
        }
#ifdef CEU_ORGS
        if (stk->org != org) {
            if (ceu_org_is_cleared(stk->org, org, t1, t2)) {
                stk->is_alive = 0;
            }
        }
        else
#endif
        {
            if (t1<=stk->trl1 && stk->trl2<=t2) {
                stk->is_alive = 0;
            }
        }
    }
}
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char* msg = lua_tostring(lua,-1);
    ceu_out_assert_msg(msg!=NULL, "bug found");
    ceu_out_log(0, (long)msg);
    ceu_out_log(0, (long)"\n");
    ceu_out_assert(0);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

#ifdef CEU_DEBUG_TRAILS
static int spc = -1;
#define SPC(n) { int i; for(i=0; i<(spc+n)*4; i++) printf(" "); };

void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF) {
    spc++;
    SPC(0); printf(">>> GO-EX\n");
    SPC(0); printf("evt: %d\n", evt->id);
    #ifdef CEU_ORGS
    SPC(0); printf("org: %p\n", org);
    SPC(2); printf("[%p]=>[%p]\n", &org->trls[0],
                                   &org->trls[org->n]);
    #endif

    ceu_sys_go_ex_dbg(app,evt,stk,org,trl0,trlF);

    SPC(0); printf("<<< GO-EX\n");
    spc--;
}
#endif

#ifdef CEU_DEBUG_TRAILS
void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
#else
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
    /* TODO: now all arguments are required in all configurations */
#endif
{
    tceu_ntrl trlI;
    tceu_trl* trl;
    for (trlI=trl0, trl=&org->trls[trlI];
#ifdef CEU_STACK_CLEAR
         stk->is_alive &&
#endif
            trlI<trlF;
         trlI++, trl++)
    {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("trl: %p\n", trl);
/*SPC(2); printf("seqno: %d\n", trl->seqno);*/
SPC(2); printf("evt: %d\n", trl->evt);
SPC(2); printf("lbl: %d\n", trl->lbl);
#endif

        /* continue traversing current org */

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if ( (trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
          || (trl->evt==CEU_IN__ORG_PSED && evt->id==CEU_IN__CLEAR)
#endif
           )
        {
            tceu_org* cur = trl->org;

            if (evt->id == CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ below */
            }

            /* traverse all children */
            if (cur != NULL) {
#ifdef CEU_STACK_CLEAR
                tceu_stk stk_ = { stk, org, cur->parent_trl, cur->parent_trl, 1 };
#endif
                while (cur != NULL) {
                    tceu_org* nxt = cur->nxt;   /* save before possible free/relink */
#ifdef CEU_STACK_CLEAR
                    ceu_sys_go_ex(app, evt, &stk_, cur, 0, cur->n);
                    if (!stk->is_alive) {
                        return; /* whole outer traversal aborted */
                    }
#if 0
if (!stk_.is_alive) {
printf("aborted\n");
    break; /* all children traversal aborted */
}
#endif
#else
                    ceu_sys_go_ex(app, evt, NULL, cur, 0, cur->n);
#endif
                    cur = nxt;
                }
            }
            continue;   /* next trail after handling children */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL */
#if 0
printf("%d==%d && %d!=%d && %d>=%d\n",
        trl->evt, evt->id,
        trl->seqno, app->seqno,
        evt->id, CEU_IN_lower
);
if (evt->param != NULL) {
    printf("trl->org_or_adt=%p // param=%p\n", trl->org_or_adt,
                 ((tceu_kill*)evt->param)->org_or_adt);
}
#endif

        if (
#ifdef CEU_CLEAR
            /* if IN__CLEAR and "finalize" clause */
            (evt->id==CEU_IN__CLEAR && trl->evt==CEU_IN__CLEAR)
        ||
#endif
#ifdef CEU_ORGS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ADTS_AWAIT
                trl->is_org &&
#endif
                (trl->org_or_adt == NULL || /* for option ptrs, init'd w/ NULL  */
                 ceu_org_is_cleared((tceu_org*)trl->org_or_adt,
                    (tceu_org*)((tceu_kill*)evt->param)->org_or_adt,
                    ((tceu_kill*)evt->param)->t1,
                    ((tceu_kill*)evt->param)->t2)))
        ||
#endif
#ifdef CEU_ADTS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ORGS_AWAIT
                !trl->is_org &&
#endif
                trl->org_or_adt == ((tceu_kill*)evt->param)->org_or_adt)
        ||
#endif
            /* if evt->id matches awaiting trail */
            (trl->evt==evt->id && trl->seqno!=app->seqno
#ifdef CEU_ORGS_OR_ADTS_AWAIT
                && (evt->id != CEU_IN__ok_killed)
                    /* TODO: simplify */
#endif
#ifdef CEU_INTS
#ifdef CEU_ORGS
                && (evt->id>=CEU_IN_lower || evt->org==trl->evto)
#endif
#endif
            )
           )
        {
            /*** CODE ***/
            trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            app->code(app, evt, org, trl, stk);
#ifdef CEU_STACK_CLEAR
            if (!stk->is_alive) {
                return;
            }
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_LUA)
            if (!app->isAlive) {
#ifdef CEU_OS_KERNEL
                CEU_GC = 1;
#endif
#ifdef CEU_LUA
                lua_close(app->lua);
#endif
            }
#endif
        }

        /* DON'T EXECUTE THIS TRAIL */
        else
        {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("<<< NO\n");
#endif
#ifdef CEU_CLEAR
            if (evt->id==CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            }
#endif
        }

        /* NEXT TRAIL */

        if (trl->evt<=CEU_IN_higher && trl->seqno!=app->seqno) {
            trl->seqno = app->seqno-1;   /* keeps the gap tight */
        }
    }

#ifdef CEU_ORGS
    /* clearing the whole org? */
    if (evt->id==CEU_IN__CLEAR && org!=app->data && trl0==0 && trlF==org->n) {
        /* yes, relink and put it in the free list */
        ceu_sys_org_free(app, org);
    }
#endif
}

void ceu_sys_go_stk (tceu_app* app, int evt, void* evtp, tceu_stk* stk) {
    app->seqno++;
#ifdef CEU_DEBUG_TRAILS
    printf("===> [%d] %d\n", evt, app->seqno);
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    {
        tceu_evt evt_;
                 evt_.id = evt;
                 evt_.param = &evtp;
        ceu_sys_go_ex(app, &evt_,
                      stk,
                      app->data, 0,
#ifdef CEU_ORGS
                      app->data->n
#else
                      CEU_NTRAILS
#endif
        );
    }

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    while (app->tofree != NULL) {
        tceu_org* nxt = app->tofree->nxt;
        ceu_sys_realloc(app->tofree, 0);
        app->tofree = nxt;
    }
#endif
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { NULL, NULL, 0, 0, 1 };
    ceu_sys_go_stk(app, evt, evtp, &stk_);
#else
    ceu_sys_go_stk(app, evt, evtp, NULL);
#endif
}

typedef struct {
    int    argc;
    char** argv;
} tceu_os_start;

int ceu_go_all (tceu_app* app, int argc, char **argv)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        tceu_os_start arg = { argc, argv };
        ceu_sys_go(app, CEU_IN_OS_START, &arg);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        if (app->threads_n > 0) {
            CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex_external);
            CEU_THREADS_SLEEP(100); /* allow threads to do "atomic" and "terminate" */
            CEU_THREADS_MUTEX_LOCK(&app->threads_mutex_external);
        }
#endif
    }
#endif

/* TODO: app.close() ? */
#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex_external);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

#endif /* !CEU_OS_APP */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_SYS_H
#define _CEU_SYS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

    #define CEU_QUEUE_MAX 65536

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISRS
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_lua_concat(l,n)                  lua_concat(l,n)
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushboolean(l,v)             lua_pushboolean(l,v)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlstring(l,v,n)           lua_pushlstring(l,v,n)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex_internal;
    CEU_THREADS_MUTEX_T threads_mutex_external;
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       is_aborted;
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int ceu_go_all (tceu_app* app, int argc, char **argv);

#ifdef CEU_WCLOCKS
int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void ceu_sys_go (tceu_app* app, int evt, void* evtp);

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len, int force);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_copy_buffer (tceu_vector* to, int idx, const byte* fr, int n, int force);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

int ceu_vector_setlen (tceu_vector* vector, int nxt, int force) {
    if (nxt<=vector->nxt || force)
    {
#ifdef CEU_VECTOR_MALLOC
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
        else
#endif
        {
            if (nxt > vector->max) {
                return 0;
            }
        }

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }
    } else {
        /* can only decrease vector->nxt */
        return 0;
    }

    vector->nxt = nxt;
    return 1;
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    return ceu_vector_copy_buffer(to,
                                  ceu_vector_getlen(to),
                                  fr->mem,
                                  ceu_vector_getlen(fr)*fr->unit,
                                  1);
}

int ceu_vector_copy_buffer (tceu_vector* to, int idx, const byte* fr, int n, int force) {
    ceu_out_assert_msg((n % to->unit) == 0, "bug found");
    int len = idx + n/to->unit;
    if (ceu_vector_getlen(to)<len && !ceu_vector_setlen(to,len,force)) {
        return 0;
    } else {
        memcpy(&to->mem[idx*to->unit], fr, n);
        return 1;
    }
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */

#line 118 "./arch/sdl.ceu"

    int SDL_Rect_vs_Mouse (SDL_Rect* r, SDL_MouseButtonEvent* but) {
        return (but->x >= r->x) && (but->x <= r->x+r->w)
            && (but->y >= r->y) && (but->y <= r->y+r->h);
    }
    int SDL_Rect_vs_Point (SDL_Rect* r, SDL_Point* pt) {
        return (pt->x >= r->x) && (pt->x <= r->x+r->w)
            && (pt->y >= r->y) && (pt->y <= r->y+r->h);
    }
    SDL_Point* SDL_Touch2Point (SDL_Point* pt, SDL_TouchFingerEvent* e, int w, int h) {
        pt->x = e->x * w;
        pt->y = e->y * h;
        return pt;
    }

    SDL_Point SDL_Rect2Point (SDL_Rect* r) {
        SDL_Point pt = { r->x+r->w/2, r->y+r->h/2 };
        return pt;
    }
    SDL_Rect SDL_Point2Rect (SDL_Point* pt, int radix) {
        SDL_Rect r = { pt->x-radix, pt->y-radix, radix*2, radix*2 };
        return r;
    }
#ifdef SDL_MATH
    int SDL_Circle_vs_Mouse (SDL_Point* pos, int rad, SDL_MouseButtonEvent* but) {
        SDL_Point pt = { but->x, but->y };
        return SDL_Circle_vs_Point(pos, rad, &pt);
    }

    int SDL_Circle_vs_Point (SDL_Point* pos, int rad, SDL_Point* pt) {
        return (pow(pos->x-pt->x,2) + pow(pos->y-pt->y,2)) <= pow(rad+rad,2);
    }

    int SDL_Circle_vs_Circle (SDL_Point* pos1, int rad1, SDL_Point* pos2, int rad2) {
        return (pow(pos1->x-pos2->x,2) + pow(pos1->y-pos2->y,2))
                <= pow(rad1+rad2,2);
    }
#endif

/* goto labels */
enum {
    Main_Set_out_0 = 0,
    SDL_Block__fin_1 = 1,
    SDL_Block__fin_2 = 2,
    SDL_vector_fin_free_3 = 3,
    Class_SDL = 4,
    Player_Set_out_5 = 5,
    Player_ParEver_sub_1_6 = 6,
    Player_ParEver_sub_2_7 = 7,
    Player_ParEver_sub_3_8 = 8,
    Player_ParEver_out_9 = 9,
    Player_Awake_SDL_DT_10 = 10,
    Player_ParEver_sub_1_11 = 11,
    Player_ParEver_sub_2_12 = 12,
    Player_ParEver_sub_3_13 = 13,
    Player_ParEver_out_14 = 14,
    Player_Awake_SDL_KEYDOWN_15 = 15,
    Player_Awake_SDL_KEYUP_16 = 16,
    Player_Awake_SDL_KEYDOWN_17 = 17,
    Player_Awake_SDL_KEYUP_18 = 18,
    Player_Awake_SDL_KEYDOWN_19 = 19,
    Player_Awake_SDL_KEYUP_20 = 20,
    Player_Awake_SDL_KEYDOWN_21 = 21,
    Player_Awake_SDL_KEYUP_22 = 22,
    Player_Awake_SDL_REDRAW_23 = 23,
    Player_Awake_SDL_DT_24 = 24,
    Player_Awake_playerHit_25 = 25,
    Class_Player = 26,
    Main_ParOr_sub_1_27 = 27,
    Main_ParOr_sub_2_28 = 28,
    Main_ParOr_sub_3_29 = 29,
    Main_ParOr_out_30 = 30,
    Main_Awake_SDL_QUIT_31 = 31,
    Main_Awake_SDL_REDRAW_32 = 32,
    Main_Awake_DT_33 = 33,
    Main_Awake_SDL_REDRAW_34 = 34,
    Main_Block__fin_35 = 35,
    Class_Main = 36,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif

void CEU_SDL_Color_free (void* pool, CEU_SDL_Color* me);

void CEU_SDL_Color_free (void* pool, CEU_SDL_Color* me) {
}



void CEU_SDL_Point_free (void* pool, CEU_SDL_Point* me);

void CEU_SDL_Point_free (void* pool, CEU_SDL_Point* me) {
}



void CEU_SDL_Rect_free (void* pool, CEU_SDL_Rect* me);

void CEU_SDL_Rect_free (void* pool, CEU_SDL_Rect* me) {
}



void CEU__Option___SDL_Window__ref_free (void* pool, CEU__Option___SDL_Window__ref* me);

CEU__Option___SDL_Window__ref* CEU__OPTION___SDL_WINDOW__REF_NIL_assert (tceu_app* app, CEU__Option___SDL_Window__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_WINDOW__REF_NIL, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_WINDOW__REF_NIL_free (void* pool, CEU__Option___SDL_Window__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU__Option___SDL_Window__ref* CEU__OPTION___SDL_WINDOW__REF_SOME_assert (tceu_app* app, CEU__Option___SDL_Window__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_WINDOW__REF_SOME, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_WINDOW__REF_SOME_free (void* pool, CEU__Option___SDL_Window__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU__Option___SDL_Window__ref_free (void* pool, CEU__Option___SDL_Window__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_WINDOW__REF_NIL:
            CEU__OPTION___SDL_WINDOW__REF_NIL_free(pool, me);
            break;
        case CEU__OPTION___SDL_WINDOW__REF_SOME:
            CEU__OPTION___SDL_WINDOW__REF_SOME_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}

CEU__Option___SDL_Window__ref CEU__OPTION___SDL_WINDOW__REF_pack (SDL_Window* v) {
    CEU__Option___SDL_Window__ref ret;
    if (v == NULL) {
        ret.tag = CEU__OPTION___SDL_WINDOW__REF_NIL;
    } else
    {
        ret.tag = CEU__OPTION___SDL_WINDOW__REF_SOME;
        ret.SOME.v = v;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
SDL_Window* CEU__OPTION___SDL_WINDOW__REF_unpack (CEU__Option___SDL_Window__ref me) {
    if (me.tag == CEU__OPTION___SDL_WINDOW__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif


void CEU__Option___SDL_Renderer__ref_free (void* pool, CEU__Option___SDL_Renderer__ref* me);

CEU__Option___SDL_Renderer__ref* CEU__OPTION___SDL_RENDERER__REF_NIL_assert (tceu_app* app, CEU__Option___SDL_Renderer__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_RENDERER__REF_NIL, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_RENDERER__REF_NIL_free (void* pool, CEU__Option___SDL_Renderer__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU__Option___SDL_Renderer__ref* CEU__OPTION___SDL_RENDERER__REF_SOME_assert (tceu_app* app, CEU__Option___SDL_Renderer__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_RENDERER__REF_SOME, "invalid tag", file, line);
    return me;
}

void CEU__OPTION___SDL_RENDERER__REF_SOME_free (void* pool, CEU__Option___SDL_Renderer__ref* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU__Option___SDL_Renderer__ref_free (void* pool, CEU__Option___SDL_Renderer__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_RENDERER__REF_NIL:
            CEU__OPTION___SDL_RENDERER__REF_NIL_free(pool, me);
            break;
        case CEU__OPTION___SDL_RENDERER__REF_SOME:
            CEU__OPTION___SDL_RENDERER__REF_SOME_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}

CEU__Option___SDL_Renderer__ref CEU__OPTION___SDL_RENDERER__REF_pack (SDL_Renderer* v) {
    CEU__Option___SDL_Renderer__ref ret;
    if (v == NULL) {
        ret.tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
    } else
    {
        ret.tag = CEU__OPTION___SDL_RENDERER__REF_SOME;
        ret.SOME.v = v;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
SDL_Renderer* CEU__OPTION___SDL_RENDERER__REF_unpack (CEU__Option___SDL_Renderer__ref me) {
    if (me.tag == CEU__OPTION___SDL_RENDERER__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif




/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/* avoids "unused variable" warnings */
void __ceu_nothing     (void* ptr) {}
int  __ceu_nothing_int (void* ptr, int v) { return v; }

/**********************************************************************/

#ifdef CEU_ORGS
static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {
/* NODE: BlockI 800 */

#line 160 "./arch/sdl.ceu"
    ceu_vector_init(&((CEU_SDL*)__ceu_this)->title,0,sizeof(char),
                (byte*)((CEU_SDL*)__ceu_this)->title_mem);
/* NODE: Stmts 818 */

#line 160 "./arch/sdl.ceu"
    {/* NODE: Dcl_mode 31 */
/* NODE: Dcl_var 802 */
/* NODE: Dcl_var 805 */
/* NODE: Dcl_var 807 */
/* NODE: Dcl_var 810 */
/* NODE: Dcl_mode 38 */
/* NODE: Dcl_var 813 */
/* NODE: Dcl_var 816 */
/* NODE: Dcl_fun 53 */

#line 160 "./arch/sdl.ceu"
    }}
static void _ceu_pre_2 (tceu_app* _ceu_app, tceu_org* __ceu_this) {
/* NODE: BlockI 887 */
/* NODE: Stmts 913 */

#line 35 "../final/game.ceu"
    {/* NODE: Dcl_var 889 */
/* NODE: Dcl_var 892 */
/* NODE: Set 896 */

#line 36 "../final/game.ceu"
/* SET: x *//* NODE: Op2_* 270 */

#line 36 "../final/game.ceu"
    (((CEU_Player*)__ceu_this)->x) = (((640/2)-(20/2))*1000);/* NODE: Dcl_var 898 */
/* NODE: Set 902 */

#line 37 "../final/game.ceu"
/* SET: y *//* NODE: Op2_* 277 */

#line 37 "../final/game.ceu"
    (((CEU_Player*)__ceu_this)->y) = ((480-50)*1000);/* NODE: Dcl_var 904 */
/* NODE: Set 908 */

#line 38 "../final/game.ceu"
/* SET: r *//* NODE: Op2_call 286 */

#line 38 "../final/game.ceu"
    {
    SDL_Rect __ceu_v_908 = 
#ifdef __cplusplus
    SDL_Rect((((CEU_Player*)__ceu_this)->x),(((CEU_Player*)__ceu_this)->y),20,20)
#else
    {(((CEU_Player*)__ceu_this)->x),(((CEU_Player*)__ceu_this)->y),20,20}
#endif
;
    (((CEU_Player*)__ceu_this)->r) = __ceu_v_908;
}
/* NODE: Dcl_int 911 */

#line 35 "../final/game.ceu"
    }}

#endif

#ifdef CEU_ORGS
static void _ceu_constr_607 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 607 */
/* NODE: Block 606 */

#line 129 "../final/game.ceu"
    {/* NODE: Stmts 605 */

#line 129 "../final/game.ceu"
    {/* NODE: Set 1510 */

#line 129 "../final/game.ceu"
/* SET: . *//* NODE: Op1_& 603 */

#line 129 "../final/game.ceu"
    (((*((CEU_Player*)__ceu_this)).ren)) = ((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->renderer),__FILE__,__LINE__)->SOME.v));
#line 129 "../final/game.ceu"
    }
#line 129 "../final/game.ceu"
/* CLEAR: Block (129) */
#line 129 "../final/game.ceu"
    if (0) {

#line 129 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

#ifdef CEU_ISRS
/* ISRS_C */

#endif

/* FUNCTIONS_C */
void CEU_SDL_build (tceu_app* _ceu_app, CEU_SDL* __ceu_this, int flags, int w, int h, char* title)
{/* NODE: Block 86 */

#line 171 "./arch/sdl.ceu"
    {
#line 171 "./arch/sdl.ceu"
    int __ceu_flags_18;

#line 171 "./arch/sdl.ceu"
    __ceu_flags_18 = flags;
#line 171 "./arch/sdl.ceu"
    int __ceu_w_19;

#line 171 "./arch/sdl.ceu"
    __ceu_w_19 = w;
#line 171 "./arch/sdl.ceu"
    int __ceu_h_20;

#line 171 "./arch/sdl.ceu"
    __ceu_h_20 = h;
#line 171 "./arch/sdl.ceu"
    char* __ceu_title_21;

#line 171 "./arch/sdl.ceu"
    __ceu_title_21 = title;/* NODE: Stmts 85 */

#line 171 "./arch/sdl.ceu"
    {/* NODE: Set 819 */

#line 171 "./arch/sdl.ceu"
/* SET: . *//* NODE: Var 68 */

#line 171 "./arch/sdl.ceu"
    (((*((CEU_SDL*)__ceu_this)).flags)) = (__ceu_flags_18);/* NODE: Set 820 */

#line 172 "./arch/sdl.ceu"
/* SET: . *//* NODE: Var 72 */

#line 172 "./arch/sdl.ceu"
    (((*((CEU_SDL*)__ceu_this)).w)) = (__ceu_w_19);/* NODE: Set 821 */

#line 173 "./arch/sdl.ceu"
/* SET: . *//* NODE: Var 76 */

#line 173 "./arch/sdl.ceu"
    (((*((CEU_SDL*)__ceu_this)).h)) = (__ceu_h_20);/* NODE: Set 822 */

#line 174 "./arch/sdl.ceu"
/* SET: . *//* NODE: Vector_constr 83 */

#line 174 "./arch/sdl.ceu"
        ceu_vector_setlen((&((*((CEU_SDL*)__ceu_this)).title)), 0, 0);
    
#line 174 "./arch/sdl.ceu"
    #line 174 "./arch/sdl.ceu"
    ceu_out_assert_msg(ceu_vector_copy_buffer((&((*((CEU_SDL*)__ceu_this)).title)), ceu_vector_getlen((&((*((CEU_SDL*)__ceu_this)).title))),(byte*)(__ceu_title_21), strlen((__ceu_title_21)),1), "access out of bounds");
    
#line 171 "./arch/sdl.ceu"
    }
#line 171 "./arch/sdl.ceu"
/* CLEAR: Block (171) */
#line 171 "./arch/sdl.ceu"
    if (0) {

#line 171 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}


/**********************************************************************/

#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static void ceu_app_go (tceu_app* _ceu_app, tceu_evt* _ceu_evt, tceu_org* _ceu_org, tceu_trl* _ceu_trl,
                        tceu_stk* _ceu_stk)
{
    tceu_nlbl _ceu_lbl = _ceu_trl->lbl;

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_org;
#endif
    _ceu_app->lst.trl = _ceu_trl;
    _ceu_app->lst.lbl = _ceu_lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _ceu_lbl, _ceu_org);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_lbl) {
        /* NODE: Root 652 */
/* NODE: Dcl_cls 0 */

#line 1 "../final/game.ceu"
case Class_Main:;/* NODE: Block 1586 */

#line 1 "../final/game.ceu"
    {/* NODE: Stmts 1585 */

#line 1 "../final/game.ceu"
    {/* NODE: Block 658 */

#line 1 "../final/game.ceu"
    {/* NODE: Stmts 657 */

#line 1 "../final/game.ceu"
    {/* NODE: Dcl_var 654 */
/* NODE: SetBlock 656 */
/* NODE: Block 650 */

#line 1 "../final/game.ceu"
    {/* NODE: Stmts 649 */

#line 1 "../final/game.ceu"
    {/* NODE: Stmts 646 */

#line 1 "../final/game.ceu"
    {/* NODE: Block 639 */

#line 1 "../final/game.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 8 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 8 ].lbl = Main_Block__fin_35;

#line 1 "../final/game.ceu"
    ((CEU_Main*)_ceu_org)->__fin_639_1 = 0;
#line 1 "../final/game.ceu"
    ((CEU_Main*)_ceu_org)->__fin_639_2 = 0;
#line 1 "../final/game.ceu"
    {
#line 1 "../final/game.ceu"
    (((CEU_Main*)_ceu_org)->window).tag = CEU__OPTION___SDL_WINDOW__REF_NIL;

#line 1 "../final/game.ceu"
    (((CEU_Main*)_ceu_org)->renderer).tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
/* NODE: Stmts 636 */

#line 4 "./arch/sdl.ceu"
    {/* NODE: Stmts 638 */

#line 1 "../final/game.ceu"
    {
#line 1 "../final/game.ceu"
    }/* NODE: Dcl_adt 8 */
/* NODE: Dcl_adt 13 */
/* NODE: Dcl_adt 22 */
/* NODE: Stmts 692 */

#line 23 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 690 */
/* NODE: Dcl_nat 691 */

#line 23 "./arch/sdl.ceu"
    }/* NODE: Stmts 696 */

#line 24 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 693 */
/* NODE: Dcl_nat 694 */
/* NODE: Dcl_nat 695 */

#line 24 "./arch/sdl.ceu"
    }/* NODE: Stmts 705 */

#line 26 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 697 */
/* NODE: Dcl_nat 698 */
/* NODE: Dcl_nat 699 */
/* NODE: Dcl_nat 700 */
/* NODE: Dcl_nat 701 */
/* NODE: Dcl_nat 702 */
/* NODE: Dcl_nat 703 */
/* NODE: Dcl_nat 704 */

#line 26 "./arch/sdl.ceu"
    }/* NODE: Stmts 725 */

#line 33 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 706 */
/* NODE: Dcl_nat 707 */
/* NODE: Dcl_nat 708 */
/* NODE: Dcl_nat 709 */
/* NODE: Dcl_nat 710 */
/* NODE: Dcl_nat 711 */
/* NODE: Dcl_nat 712 */
/* NODE: Dcl_nat 713 */
/* NODE: Dcl_nat 714 */
/* NODE: Dcl_nat 715 */
/* NODE: Dcl_nat 716 */
/* NODE: Dcl_nat 717 */
/* NODE: Dcl_nat 718 */
/* NODE: Dcl_nat 719 */
/* NODE: Dcl_nat 720 */
/* NODE: Dcl_nat 721 */
/* NODE: Dcl_nat 722 */
/* NODE: Dcl_nat 723 */
/* NODE: Dcl_nat 724 */

#line 33 "./arch/sdl.ceu"
    }/* NODE: Stmts 730 */

#line 51 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 726 */
/* NODE: Dcl_nat 727 */
/* NODE: Dcl_nat 728 */
/* NODE: Dcl_nat 729 */

#line 51 "./arch/sdl.ceu"
    }/* NODE: Stmts 783 */

#line 56 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 731 */
/* NODE: Dcl_nat 732 */
/* NODE: Dcl_nat 733 */
/* NODE: Dcl_nat 734 */
/* NODE: Dcl_nat 735 */
/* NODE: Dcl_nat 736 */
/* NODE: Dcl_nat 737 */
/* NODE: Dcl_nat 738 */
/* NODE: Dcl_nat 739 */
/* NODE: Dcl_nat 740 */
/* NODE: Dcl_nat 741 */
/* NODE: Dcl_nat 742 */
/* NODE: Dcl_nat 743 */
/* NODE: Dcl_nat 744 */
/* NODE: Dcl_nat 745 */
/* NODE: Dcl_nat 746 */
/* NODE: Dcl_nat 747 */
/* NODE: Dcl_nat 748 */
/* NODE: Dcl_nat 749 */
/* NODE: Dcl_nat 750 */
/* NODE: Dcl_nat 751 */
/* NODE: Dcl_nat 752 */
/* NODE: Dcl_nat 753 */
/* NODE: Dcl_nat 754 */
/* NODE: Dcl_nat 755 */
/* NODE: Dcl_nat 756 */
/* NODE: Dcl_nat 757 */
/* NODE: Dcl_nat 758 */
/* NODE: Dcl_nat 759 */
/* NODE: Dcl_nat 760 */
/* NODE: Dcl_nat 761 */
/* NODE: Dcl_nat 762 */
/* NODE: Dcl_nat 763 */
/* NODE: Dcl_nat 764 */
/* NODE: Dcl_nat 765 */
/* NODE: Dcl_nat 766 */
/* NODE: Dcl_nat 767 */
/* NODE: Dcl_nat 768 */
/* NODE: Dcl_nat 769 */
/* NODE: Dcl_nat 770 */
/* NODE: Dcl_nat 771 */
/* NODE: Dcl_nat 772 */
/* NODE: Dcl_nat 773 */
/* NODE: Dcl_nat 774 */
/* NODE: Dcl_nat 775 */
/* NODE: Dcl_nat 776 */
/* NODE: Dcl_nat 777 */
/* NODE: Dcl_nat 778 */
/* NODE: Dcl_nat 779 */
/* NODE: Dcl_nat 780 */
/* NODE: Dcl_nat 781 */
/* NODE: Dcl_nat 782 */

#line 56 "./arch/sdl.ceu"
    }/* NODE: Stmts 792 */

#line 109 "./arch/sdl.ceu"
    {/* NODE: Dcl_nat 784 */
/* NODE: Dcl_nat 785 */
/* NODE: Dcl_nat 786 */
/* NODE: Dcl_nat 787 */
/* NODE: Dcl_nat 788 */
/* NODE: Dcl_nat 789 */
/* NODE: Dcl_nat 790 */
/* NODE: Dcl_nat 791 */

#line 109 "./arch/sdl.ceu"
    }/* NODE: Host 30 */
/* NODE: Stmts 846 */

#line 3 "../final/game.ceu"
    {/* NODE: Dcl_ext 845 */

#line 3 "../final/game.ceu"
    }/* NODE: Stmts 849 */

#line 4 "../final/game.ceu"
    {/* NODE: Dcl_ext 848 */

#line 4 "../final/game.ceu"
    }/* NODE: Stmts 853 */

#line 5 "../final/game.ceu"
    {/* NODE: Dcl_ext 852 */

#line 5 "../final/game.ceu"
    }/* NODE: Stmts 857 */

#line 6 "../final/game.ceu"
    {/* NODE: Dcl_ext 856 */

#line 6 "../final/game.ceu"
    }/* NODE: Stmts 861 */

#line 7 "../final/game.ceu"
    {/* NODE: Dcl_ext 860 */

#line 7 "../final/game.ceu"
    }/* NODE: Stmts 865 */

#line 8 "../final/game.ceu"
    {/* NODE: Dcl_ext 864 */

#line 8 "../final/game.ceu"
    }/* NODE: Stmts 867 */

#line 9 "../final/game.ceu"
    {/* NODE: Dcl_int 866 */

#line 9 "../final/game.ceu"
    }/* NODE: Stmts 871 */

#line 10 "../final/game.ceu"
    {/* NODE: Dcl_int 870 */

#line 10 "../final/game.ceu"
    }/* NODE: Stmts 874 */

#line 13 "../final/game.ceu"
    {/* NODE: Dcl_var 873 */

#line 13 "../final/game.ceu"
    }/* NODE: Finalize 233 */

#line 14 "../final/game.ceu"
    ((CEU_Main*)_ceu_org)->__fin_639_2 = 1;/* NODE: Set 875 */

#line 15 "../final/game.ceu"
/* SET: window *//* NODE: Op1_& 221 */

#line 15 "../final/game.ceu"
    (((CEU_Main*)_ceu_org)->window) = (CEU__OPTION___SDL_WINDOW__REF_pack(SDL_CreateWindow("Game",SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,640,480,SDL_WINDOW_SHOWN)));/* NODE: Stmts 878 */

#line 23 "../final/game.ceu"
    {/* NODE: Dcl_var 877 */

#line 23 "../final/game.ceu"
    }/* NODE: Finalize 258 */

#line 24 "../final/game.ceu"
    ((CEU_Main*)_ceu_org)->__fin_639_1 = 1;/* NODE: Set 879 */

#line 25 "../final/game.ceu"
/* SET: renderer *//* NODE: Op1_& 246 */

#line 25 "../final/game.ceu"
    (((CEU_Main*)_ceu_org)->renderer) = (CEU__OPTION___SDL_RENDERER__REF_pack(SDL_CreateRenderer(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->window),__FILE__,__LINE__)->SOME.v)),(-1),0)));/* NODE: CallStmt 568 */

#line 112 "../final/game.ceu"
    srand(time(NULL));/* NODE: ParOr 633 */

#line 116 "../final/game.ceu"
/* ParOr: spawn subs */
#line 116 "../final/game.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 7, 1 };
#endif

#line 116 "../final/game.ceu"
        _ceu_org->trls[ 0 ].lbl = Main_ParOr_sub_1_27;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 116 "../final/game.ceu"
        _ceu_org->trls[ 1 ].lbl = Main_ParOr_sub_2_28;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 116 "../final/game.ceu"
        _ceu_org->trls[ 2 ].lbl = Main_ParOr_sub_3_29;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 116 "../final/game.ceu"
        _ceu_trl = &_ceu_org->trls[ 4 ];

#line 116 "../final/game.ceu"
    }
/* NODE: Block 632 */

#line 136 "../final/game.ceu"
    {/* NODE: Stmts 631 */

#line 136 "../final/game.ceu"
    {/* NODE: Block 1553 */

#line 136 "../final/game.ceu"
    {/* NODE: Stmts 1552 */

#line 136 "../final/game.ceu"
    {/* NODE: Stmts 1551 */

#line 136 "../final/game.ceu"
    {
#line 136 "../final/game.ceu"
    }/* NODE: Loop 1550 */

#line 136 "../final/game.ceu"
    for (;;) {
/* NODE: Block 629 */

#line 137 "../final/game.ceu"
    {/* NODE: Stmts 628 */

#line 137 "../final/game.ceu"
    {/* NODE: Stmts 1580 */

#line 136 "../final/game.ceu"
    {/* NODE: Nothing 1554 */
/* NODE: Await 1547 */

#line 136 "../final/game.ceu"
    goto _CEU_NO_1547_; /* avoids "not used" warning */
_CEU_NO_1547_:;

#line 136 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_REDRAW;
_ceu_trl->lbl = Main_Awake_SDL_REDRAW_34;
_ceu_trl->seqno = _ceu_app->seqno;

#line 136 "../final/game.ceu"
    return;

case Main_Awake_SDL_REDRAW_34:;

#line 136 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1683 */
/* NODE: Nothing 1684 */

#line 136 "../final/game.ceu"
    }/* NODE: CallStmt 627 */

#line 137 "../final/game.ceu"
    SDL_RenderPresent(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->renderer),__FILE__,__LINE__)->SOME.v)));
#line 137 "../final/game.ceu"
    }
#line 137 "../final/game.ceu"
/* CLEAR: Block (137) */
#line 137 "../final/game.ceu"
    if (0) {

#line 137 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 136 "../final/game.ceu"
    }

#line 136 "../final/game.ceu"
    }
#line 136 "../final/game.ceu"
/* CLEAR: Block (136) */
#line 136 "../final/game.ceu"
    if (0) {

#line 136 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 136 "../final/game.ceu"
    }
#line 136 "../final/game.ceu"
/* CLEAR: Block (136) */
#line 136 "../final/game.ceu"
    if (0) {

#line 136 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 116 "../final/game.ceu"
case Main_ParOr_sub_3_29:;/* NODE: Block 619 */

#line 128 "../final/game.ceu"
    {
#line 128 "../final/game.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 128 "../final/game.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 618 */

#line 128 "../final/game.ceu"
    {/* NODE: Dcl_var 608 */

#line 128 "../final/game.ceu"
/* start org: p */
#line 128 "../final/game.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15)),8,Class_Player,
                     2,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 128 "../final/game.ceu"
        _ceu_pre_2(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15)));

#line 128 "../final/game.ceu"
        _ceu_constr_607(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15)), _ceu_org);

#line 128 "../final/game.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 3, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->p_15))->trls[0],
               NULL);
#endif

#line 128 "../final/game.ceu"
    }
/* NODE: Block 1517 */

#line 131 "../final/game.ceu"
    {/* NODE: Stmts 1516 */

#line 131 "../final/game.ceu"
    {/* NODE: Stmts 1515 */

#line 131 "../final/game.ceu"
    {
#line 131 "../final/game.ceu"
    }/* NODE: Loop 1514 */

#line 131 "../final/game.ceu"
    for (;;) {
/* NODE: Block 616 */

#line 132 "../final/game.ceu"
    {/* NODE: Stmts 615 */

#line 132 "../final/game.ceu"
    {/* NODE: Stmts 1545 */

#line 131 "../final/game.ceu"
    {/* NODE: Nothing 1519 */
/* NODE: Await 1511 */

#line 131 "../final/game.ceu"
    ceu_out_wclock(_ceu_app, (s32)((s32)10000000), &((CEU_Main*)_ceu_org)->__wclk_1511, NULL);

#line 131 "../final/game.ceu"
    goto _CEU_NO_1511_; /* avoids "not used" warning */
_CEU_NO_1511_:;

#line 131 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN__WCLOCK;
_ceu_trl->lbl = Main_Awake_DT_33;
_ceu_trl->seqno = _ceu_app->seqno;

#line 131 "../final/game.ceu"
    return;

case Main_Awake_DT_33:;

#line 131 "../final/game.ceu"
        /* subtract time and check if I have to awake */
    {
        s32** __ceu_casted = (s32**)_ceu_evt->param;
        if (!ceu_out_wclock(_ceu_app, *(*__ceu_casted), NULL, &((CEU_Main*)_ceu_org)->__wclk_1511) ) {
            goto _CEU_NO_1511_;
        }
    }

#line 131 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1681 */
/* NODE: Nothing 1682 */

#line 131 "../final/game.ceu"
    }/* NODE: CallStmt 614 */

#line 132 "../final/game.ceu"
    printf("hi\n");
#line 132 "../final/game.ceu"
    }
#line 132 "../final/game.ceu"
/* CLEAR: Block (132) */
#line 132 "../final/game.ceu"
    if (0) {

#line 132 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 131 "../final/game.ceu"
    }

#line 131 "../final/game.ceu"
    }
#line 131 "../final/game.ceu"
/* CLEAR: Block (131) */
#line 131 "../final/game.ceu"
    if (0) {

#line 131 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 128 "../final/game.ceu"
    }
#line 128 "../final/game.ceu"
/* CLEAR: Block (128) */
#line 128 "../final/game.ceu"
    if (0) {

#line 128 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 116 "../final/game.ceu"
case Main_ParOr_sub_2_28:;/* NODE: Block 597 */

#line 119 "../final/game.ceu"
    {/* NODE: Stmts 596 */

#line 119 "../final/game.ceu"
    {/* NODE: Block 1482 */

#line 119 "../final/game.ceu"
    {/* NODE: Stmts 1481 */

#line 119 "../final/game.ceu"
    {/* NODE: Stmts 1480 */

#line 119 "../final/game.ceu"
    {
#line 119 "../final/game.ceu"
    }/* NODE: Loop 1479 */

#line 119 "../final/game.ceu"
    for (;;) {
/* NODE: Block 594 */

#line 120 "../final/game.ceu"
    {/* NODE: Stmts 593 */

#line 120 "../final/game.ceu"
    {/* NODE: Stmts 1509 */

#line 119 "../final/game.ceu"
    {/* NODE: Nothing 1483 */
/* NODE: Await 1476 */

#line 119 "../final/game.ceu"
    goto _CEU_NO_1476_; /* avoids "not used" warning */
_CEU_NO_1476_:;

#line 119 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_REDRAW;
_ceu_trl->lbl = Main_Awake_SDL_REDRAW_32;
_ceu_trl->seqno = _ceu_app->seqno;

#line 119 "../final/game.ceu"
    return;

case Main_Awake_SDL_REDRAW_32:;

#line 119 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1678 */
/* NODE: Nothing 1679 */

#line 119 "../final/game.ceu"
    }/* NODE: CallStmt 584 */

#line 120 "../final/game.ceu"
    SDL_SetRenderDrawColor(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->renderer),__FILE__,__LINE__)->SOME.v)),0xFF,0xFF,0xFF,0x00);/* NODE: CallStmt 592 */

#line 122 "../final/game.ceu"
    SDL_RenderFillRect(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->renderer),__FILE__,__LINE__)->SOME.v)),NULL);
#line 120 "../final/game.ceu"
    }
#line 120 "../final/game.ceu"
/* CLEAR: Block (120) */
#line 120 "../final/game.ceu"
    if (0) {

#line 120 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 119 "../final/game.ceu"
    }

#line 119 "../final/game.ceu"
    }
#line 119 "../final/game.ceu"
/* CLEAR: Block (119) */
#line 119 "../final/game.ceu"
    if (0) {

#line 119 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 119 "../final/game.ceu"
    }
#line 119 "../final/game.ceu"
/* CLEAR: Block (119) */
#line 119 "../final/game.ceu"
    if (0) {

#line 119 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 116 "../final/game.ceu"
case Main_ParOr_sub_1_27:;/* NODE: Block 572 */

#line 117 "../final/game.ceu"
    {/* NODE: Stmts 571 */

#line 117 "../final/game.ceu"
    {/* NODE: Stmts 1475 */

#line 117 "../final/game.ceu"
    {/* NODE: Nothing 1449 */
/* NODE: Await 570 */

#line 117 "../final/game.ceu"
    goto _CEU_NO_570_; /* avoids "not used" warning */
_CEU_NO_570_:;

#line 117 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_QUIT;
_ceu_trl->lbl = Main_Awake_SDL_QUIT_31;
_ceu_trl->seqno = _ceu_app->seqno;

#line 117 "../final/game.ceu"
    return;

case Main_Awake_SDL_QUIT_31:;

#line 117 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1676 */
/* NODE: Nothing 1677 */

#line 117 "../final/game.ceu"
    }
#line 117 "../final/game.ceu"
    }
#line 117 "../final/game.ceu"
/* CLEAR: Block (117) */
#line 117 "../final/game.ceu"
    if (0) {

#line 117 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 116 "../final/game.ceu"
/* PAROR JOIN */
#line 116 "../final/game.ceu"
    _ceu_lbl = Main_ParOr_out_30;
goto _CEU_GOTO_;

#line 116 "../final/game.ceu"
case Main_ParOr_out_30:;
#line 116 "../final/game.ceu"
/* CLEAR: ParOr (116) */
#line 116 "../final/game.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  8);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,7);
#endif
}

#line 116 "../final/game.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,7 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: Stmts 1584 */

#line 141 "../final/game.ceu"
    {/* NODE: Set 1582 */

#line 141 "../final/game.ceu"
/* SET: _ret *//* NODE: NUMBER 634 */

#line 141 "../final/game.ceu"
    #ifdef CEU_RET

#line 141 "../final/game.ceu"
    (((CEU_Main*)_ceu_org)->_ret_0) = 0;
#line 141 "../final/game.ceu"
        _ceu_app->ret = (((CEU_Main*)_ceu_org)->_ret_0);
#endif
/* NODE: Escape 1583 */

#line 141 "../final/game.ceu"
    _ceu_lbl = Main_Set_out_0;
goto _CEU_GOTO_;

#line 141 "../final/game.ceu"
    }
#line 4 "./arch/sdl.ceu"
    }
#line 1 "../final/game.ceu"
/* CLEAR: Block (1) */
#line 1 "../final/game.ceu"
    if (0) {

#line 1 "../final/game.ceu"
case Main_Block__fin_35:;
#line 1 "../final/game.ceu"
    if (((CEU_Main*)_ceu_org)->__fin_639_1) {
    /* NODE: Finally 257 */
/* NODE: Block 256 */

#line 27 "../final/game.ceu"
    {/* NODE: Stmts 255 */

#line 27 "../final/game.ceu"
    {/* NODE: CallStmt 254 */

#line 27 "../final/game.ceu"
    SDL_DestroyRenderer(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->renderer),__FILE__,__LINE__)->SOME.v)));
#line 27 "../final/game.ceu"
    }
#line 27 "../final/game.ceu"
/* CLEAR: Block (27) */
#line 27 "../final/game.ceu"
    if (0) {

#line 27 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1 "../final/game.ceu"
    if (((CEU_Main*)_ceu_org)->__fin_639_2) {
    /* NODE: Finally 232 */
/* NODE: Block 231 */

#line 20 "../final/game.ceu"
    {/* NODE: Stmts 230 */

#line 20 "../final/game.ceu"
    {/* NODE: CallStmt 229 */

#line 20 "../final/game.ceu"
    SDL_DestroyWindow(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_ceu_org)->window),__FILE__,__LINE__)->SOME.v)));
#line 20 "../final/game.ceu"
    }
#line 20 "../final/game.ceu"
/* CLEAR: Block (20) */
#line 20 "../final/game.ceu"
    if (0) {

#line 20 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1 "../final/game.ceu"
    return;
#line 1 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "../final/game.ceu"
    }
#line 1 "../final/game.ceu"
    }
#line 1 "../final/game.ceu"
/* CLEAR: Block (1) */
#line 1 "../final/game.ceu"
    if (0) {

#line 1 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "../final/game.ceu"
    return;
#line 1 "../final/game.ceu"
case Main_Set_out_0:;
#line 1 "../final/game.ceu"
/* CLEAR: SetBlock (1) */
#line 1 "../final/game.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,8);
#endif
}

#line 1 "../final/game.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1 "../final/game.ceu"
    }
#line 1 "../final/game.ceu"
/* CLEAR: Block (1) */
#line 1 "../final/game.ceu"
    if (0) {

#line 1 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "../final/game.ceu"
    }
#line 1 "../final/game.ceu"
/* CLEAR: Block (1) */
#line 1 "../final/game.ceu"
    if (0) {

#line 1 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "../final/game.ceu"
    #if defined(CEU_RET) || defined(CEU_OS)
_ceu_app->isAlive = 0;
#endif

#line 1 "../final/game.ceu"
    return;/* NODE: Dcl_cls 1 */

#line 159 "./arch/sdl.ceu"
case Class_SDL:;/* NODE: Block 842 */

#line 159 "./arch/sdl.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = SDL_Block__fin_2;

#line 159 "./arch/sdl.ceu"
    {
#line 159 "./arch/sdl.ceu"
    /*  FINALIZE VECTOR */
_ceu_org->trls[ 0 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 0 ].lbl = SDL_vector_fin_free_3;

#line 159 "./arch/sdl.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 841 */

#line 159 "./arch/sdl.ceu"
    {/* NODE: Block 798 */

#line 159 "./arch/sdl.ceu"
    {/* NODE: Stmts 843 */

#line 159 "./arch/sdl.ceu"
    {/* NODE: Block 187 */

#line 170 "./arch/sdl.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 2 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 2 ].lbl = SDL_Block__fin_1;

#line 170 "./arch/sdl.ceu"
    ((CEU_SDL*)_ceu_org)->__fin_187_1 = 0;
#line 170 "./arch/sdl.ceu"
    ((CEU_SDL*)_ceu_org)->__fin_187_2 = 0;
#line 170 "./arch/sdl.ceu"
    ((CEU_SDL*)_ceu_org)->__fin_187_3 = 0;
#line 170 "./arch/sdl.ceu"
    {
#line 170 "./arch/sdl.ceu"
    int __ceu_err_22;

#line 170 "./arch/sdl.ceu"
    (((CEU_SDL*)_ceu_org)->win_).tag = CEU__OPTION___SDL_WINDOW__REF_NIL;

#line 170 "./arch/sdl.ceu"
    (((CEU_SDL*)_ceu_org)->ren_).tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
/* NODE: Stmts 186 */

#line 170 "./arch/sdl.ceu"
    {/* NODE: Dcl_fun 65 */
/* NODE: Stmts 827 */

#line 177 "./arch/sdl.ceu"
    {/* NODE: Dcl_var 824 */
/* NODE: Set 828 */

#line 177 "./arch/sdl.ceu"
/* SET: err *//* NODE: Op2_call 93 */

#line 177 "./arch/sdl.ceu"
    (__ceu_err_22) = SDL_Init((((*((CEU_SDL*)_ceu_org)).flags)));
#line 177 "./arch/sdl.ceu"
    }/* NODE: If 830 */

#line 178 "./arch/sdl.ceu"
    if (((__ceu_err_22)!=0)) {
/* NODE: Block 112 */

#line 179 "./arch/sdl.ceu"
    {/* NODE: Stmts 111 */

#line 179 "./arch/sdl.ceu"
    {/* NODE: CallStmt 105 */

#line 179 "./arch/sdl.ceu"
    printf("SDL_Init failed: %s\n",SDL_GetError());/* NODE: CallStmt 110 */

#line 180 "./arch/sdl.ceu"
    ceu_out_assert(0);
#line 179 "./arch/sdl.ceu"
    }
#line 179 "./arch/sdl.ceu"
/* CLEAR: Block (179) */
#line 179 "./arch/sdl.ceu"
    if (0) {

#line 179 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 829 */
}
/* NODE: Finalize 121 */

#line 182 "./arch/sdl.ceu"
    ((CEU_SDL*)_ceu_org)->__fin_187_3 = 1;/* NODE: Stmts 833 */

#line 186 "./arch/sdl.ceu"
    {/* NODE: Dcl_adt 1592 */
/* NODE: Dcl_var 832 */

#line 186 "./arch/sdl.ceu"
    }/* NODE: Finalize 148 */

#line 187 "./arch/sdl.ceu"
    ((CEU_SDL*)_ceu_org)->__fin_187_2 = 1;/* NODE: Set 834 */

#line 188 "./arch/sdl.ceu"
/* SET: win_ *//* NODE: Op1_& 136 */

#line 188 "./arch/sdl.ceu"
    (((CEU_SDL*)_ceu_org)->win_) = (CEU__OPTION___SDL_WINDOW__REF_pack(SDL_CreateWindow("xxx",SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,(((*((CEU_SDL*)_ceu_org)).w)),(((*((CEU_SDL*)_ceu_org)).h)),SDL_WINDOW_SHOWN)));/* NODE: Set 835 */

#line 197 "./arch/sdl.ceu"
/* SET: . *//* NODE: Op1_& 153 */

#line 197 "./arch/sdl.ceu"
    (((*((CEU_SDL*)_ceu_org)).win)) = ((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_SDL*)_ceu_org)->win_),__FILE__,__LINE__)->SOME.v));/* NODE: Stmts 838 */

#line 199 "./arch/sdl.ceu"
    {/* NODE: Dcl_adt 1598 */
/* NODE: Dcl_var 837 */

#line 199 "./arch/sdl.ceu"
    }/* NODE: Finalize 178 */

#line 200 "./arch/sdl.ceu"
    ((CEU_SDL*)_ceu_org)->__fin_187_1 = 1;/* NODE: Set 839 */

#line 201 "./arch/sdl.ceu"
/* SET: ren_ *//* NODE: Op1_& 166 */

#line 201 "./arch/sdl.ceu"
    (((CEU_SDL*)_ceu_org)->ren_) = (CEU__OPTION___SDL_RENDERER__REF_pack(SDL_CreateRenderer((((CEU_SDL*)_ceu_org)->win),(-1),0)));/* NODE: Set 840 */

#line 205 "./arch/sdl.ceu"
/* SET: . *//* NODE: Op1_& 183 */

#line 205 "./arch/sdl.ceu"
    (((*((CEU_SDL*)_ceu_org)).ren)) = ((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_SDL*)_ceu_org)->ren_),__FILE__,__LINE__)->SOME.v));/* NODE: AwaitN 185 */

#line 207 "./arch/sdl.ceu"
    return;
#line 170 "./arch/sdl.ceu"
    }
#line 170 "./arch/sdl.ceu"
/* CLEAR: Block (170) */
#line 170 "./arch/sdl.ceu"
    if (0) {

#line 170 "./arch/sdl.ceu"
case SDL_Block__fin_1:;
#line 170 "./arch/sdl.ceu"
    if (((CEU_SDL*)_ceu_org)->__fin_187_1) {
    /* NODE: Finally 177 */
/* NODE: Block 176 */

#line 203 "./arch/sdl.ceu"
    {/* NODE: Stmts 175 */

#line 203 "./arch/sdl.ceu"
    {/* NODE: CallStmt 174 */

#line 203 "./arch/sdl.ceu"
    SDL_DestroyRenderer(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_SDL*)_ceu_org)->ren_),__FILE__,__LINE__)->SOME.v)));
#line 203 "./arch/sdl.ceu"
    }
#line 203 "./arch/sdl.ceu"
/* CLEAR: Block (203) */
#line 203 "./arch/sdl.ceu"
    if (0) {

#line 203 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 170 "./arch/sdl.ceu"
    if (((CEU_SDL*)_ceu_org)->__fin_187_2) {
    /* NODE: Finally 147 */
/* NODE: Block 146 */

#line 195 "./arch/sdl.ceu"
    {/* NODE: Stmts 145 */

#line 195 "./arch/sdl.ceu"
    {/* NODE: CallStmt 144 */

#line 195 "./arch/sdl.ceu"
    SDL_DestroyWindow(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_SDL*)_ceu_org)->win_),__FILE__,__LINE__)->SOME.v)));
#line 195 "./arch/sdl.ceu"
    }
#line 195 "./arch/sdl.ceu"
/* CLEAR: Block (195) */
#line 195 "./arch/sdl.ceu"
    if (0) {

#line 195 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 170 "./arch/sdl.ceu"
    if (((CEU_SDL*)_ceu_org)->__fin_187_3) {
    /* NODE: Finally 120 */
/* NODE: Block 119 */

#line 183 "./arch/sdl.ceu"
    {/* NODE: Stmts 118 */

#line 183 "./arch/sdl.ceu"
    {/* NODE: CallStmt 117 */

#line 183 "./arch/sdl.ceu"
    SDL_Quit();
#line 183 "./arch/sdl.ceu"
    }
#line 183 "./arch/sdl.ceu"
/* CLEAR: Block (183) */
#line 183 "./arch/sdl.ceu"
    if (0) {

#line 183 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 170 "./arch/sdl.ceu"
    return;
#line 170 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 159 "./arch/sdl.ceu"
    }
#line 159 "./arch/sdl.ceu"
/* CLEAR: Block (159) */
#line 159 "./arch/sdl.ceu"
    if (0) {

#line 159 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 159 "./arch/sdl.ceu"
    }
#line 159 "./arch/sdl.ceu"
/* CLEAR: Block (159) */
#line 159 "./arch/sdl.ceu"
    if (0) {

#line 159 "./arch/sdl.ceu"
case SDL_Block__fin_2:;
#line 159 "./arch/sdl.ceu"
    return;
#line 159 "./arch/sdl.ceu"
case SDL_vector_fin_free_3:;
#line 159 "./arch/sdl.ceu"
    ceu_vector_setlen((&((CEU_SDL*)_ceu_org)->title), 0, 0);

#line 159 "./arch/sdl.ceu"
    return;
#line 159 "./arch/sdl.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 159 "./arch/sdl.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 159 "./arch/sdl.ceu"
    return;/* NODE: Dcl_cls 2 */

#line 34 "../final/game.ceu"
case Class_Player:;/* NODE: Block 1448 */

#line 34 "../final/game.ceu"
    {/* NODE: Stmts 1447 */

#line 34 "../final/game.ceu"
    {/* NODE: Block 885 */

#line 34 "../final/game.ceu"
    {/* NODE: Stmts 884 */

#line 34 "../final/game.ceu"
    {/* NODE: Dcl_var 881 */
/* NODE: SetBlock 883 */
/* NODE: Block 559 */

#line 41 "../final/game.ceu"
    {/* NODE: Stmts 558 */

#line 41 "../final/game.ceu"
    {/* NODE: Stmts 918 */

#line 41 "../final/game.ceu"
    {/* NODE: Dcl_var 915 */
/* NODE: Set 919 */

#line 41 "../final/game.ceu"
/* SET: life *//* NODE: NUMBER 292 */

#line 41 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->life) = 3;
#line 41 "../final/game.ceu"
    }/* NODE: Stmts 924 */

#line 42 "../final/game.ceu"
    {/* NODE: Dcl_var 921 */
/* NODE: Set 925 */

#line 42 "../final/game.ceu"
/* SET: vx *//* NODE: NUMBER 295 */

#line 42 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vx) = 0;
#line 42 "../final/game.ceu"
    }/* NODE: Stmts 930 */

#line 43 "../final/game.ceu"
    {/* NODE: Dcl_var 927 */
/* NODE: Set 931 */

#line 43 "../final/game.ceu"
/* SET: vy *//* NODE: NUMBER 298 */

#line 43 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vy) = 0;
#line 43 "../final/game.ceu"
    }/* NODE: ParEver 557 */

#line 44 "../final/game.ceu"
/* ParEver: spawn subs */
#line 44 "../final/game.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 6, 1 };
#endif

#line 44 "../final/game.ceu"
        _ceu_org->trls[ 0 ].lbl = Player_ParEver_sub_1_6;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 44 "../final/game.ceu"
        _ceu_org->trls[ 1 ].lbl = Player_ParEver_sub_2_7;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 44 "../final/game.ceu"
        _ceu_org->trls[ 5 ].lbl = Player_ParEver_sub_3_8;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 5 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 44 "../final/game.ceu"
        _ceu_trl = &_ceu_org->trls[ 6 ];

#line 44 "../final/game.ceu"
    }
/* NODE: Block 556 */

#line 96 "../final/game.ceu"
    {/* NODE: Stmts 555 */

#line 96 "../final/game.ceu"
    {/* NODE: Block 1382 */

#line 96 "../final/game.ceu"
    {/* NODE: Stmts 1381 */

#line 96 "../final/game.ceu"
    {/* NODE: Stmts 1380 */

#line 96 "../final/game.ceu"
    {
#line 96 "../final/game.ceu"
    }/* NODE: Loop 1379 */

#line 96 "../final/game.ceu"
    for (;;) {
/* NODE: Block 553 */

#line 97 "../final/game.ceu"
    {/* NODE: Stmts 552 */

#line 97 "../final/game.ceu"
    {/* NODE: Stmts 1409 */

#line 97 "../final/game.ceu"
    {/* NODE: Nothing 1383 */
/* NODE: Await 515 */

#line 97 "../final/game.ceu"
    goto _CEU_NO_515_; /* avoids "not used" warning */
_CEU_NO_515_:;

#line 97 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_DT;
_ceu_trl->lbl = Player_Awake_SDL_DT_24;
_ceu_trl->seqno = _ceu_app->seqno;

#line 97 "../final/game.ceu"
    return;

case Player_Awake_SDL_DT_24:;

#line 97 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1667 */
/* NODE: Nothing 1668 */

#line 97 "../final/game.ceu"
    }/* NODE: Stmts 1439 */

#line 98 "../final/game.ceu"
    {/* NODE: Nothing 1410 */
/* NODE: Await 518 */

#line 98 "../final/game.ceu"
    goto _CEU_NO_518_; /* avoids "not used" warning */
_CEU_NO_518_:;

#line 98 "../final/game.ceu"
    _ceu_trl->evt = 3;
_ceu_trl->lbl = Player_Awake_playerHit_25;
_ceu_trl->seqno = _ceu_app->seqno;

#line 98 "../final/game.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = ((CEU_Player*)_ceu_org);
#endif

#line 98 "../final/game.ceu"
    return;

case Player_Awake_playerHit_25:;

#line 98 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1670 */
/* NODE: Nothing 1671 */

#line 98 "../final/game.ceu"
    }/* NODE: Set 1440 */

#line 99 "../final/game.ceu"
/* SET: . *//* NODE: Op2_- 524 */

#line 99 "../final/game.ceu"
    (((*((CEU_Player*)_ceu_org)).life)) = ((((*((CEU_Player*)_ceu_org)).life))-1);/* NODE: CallStmt 532 */

#line 100 "../final/game.ceu"
    printf("life %d\n",(((*((CEU_Player*)_ceu_org)).life)));/* NODE: If 1442 */

#line 101 "../final/game.ceu"
    if (((((*((CEU_Player*)_ceu_org)).life))<=0)) {
/* NODE: Block 550 */

#line 102 "../final/game.ceu"
    {/* NODE: Stmts 549 */

#line 102 "../final/game.ceu"
    {/* NODE: CallStmt 541 */

#line 102 "../final/game.ceu"
    printf("GAME OVER\n");/* NODE: CallStmt 546 */

#line 103 "../final/game.ceu"
    exit(0);/* NODE: Stmts 1446 */

#line 104 "../final/game.ceu"
    {/* NODE: Set 1444 */

#line 104 "../final/game.ceu"
/* SET: _ret *//* NODE: NUMBER 547 */

#line 104 "../final/game.ceu"
    #ifdef CEU_ORGS_AWAIT

#line 104 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->_ret_20) = 1;
#line 104 "../final/game.ceu"
        _ceu_org->ret = (((CEU_Player*)_ceu_org)->_ret_20);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1445 */

#line 104 "../final/game.ceu"
    _ceu_lbl = Player_Set_out_5;
goto _CEU_GOTO_;

#line 104 "../final/game.ceu"
    }
#line 102 "../final/game.ceu"
    }
#line 102 "../final/game.ceu"
/* CLEAR: Block (102) */
#line 102 "../final/game.ceu"
    if (0) {

#line 102 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 1441 */
}

#line 97 "../final/game.ceu"
    }
#line 97 "../final/game.ceu"
/* CLEAR: Block (97) */
#line 97 "../final/game.ceu"
    if (0) {

#line 97 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 96 "../final/game.ceu"
    }

#line 96 "../final/game.ceu"
    }
#line 96 "../final/game.ceu"
/* CLEAR: Block (96) */
#line 96 "../final/game.ceu"
    if (0) {

#line 96 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 96 "../final/game.ceu"
    }
#line 96 "../final/game.ceu"
/* CLEAR: Block (96) */
#line 96 "../final/game.ceu"
    if (0) {

#line 96 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 44 "../final/game.ceu"
case Player_ParEver_sub_3_8:;/* NODE: Block 513 */

#line 88 "../final/game.ceu"
    {/* NODE: Stmts 512 */

#line 88 "../final/game.ceu"
    {/* NODE: Block 1349 */

#line 88 "../final/game.ceu"
    {/* NODE: Stmts 1348 */

#line 88 "../final/game.ceu"
    {/* NODE: Stmts 1347 */

#line 88 "../final/game.ceu"
    {
#line 88 "../final/game.ceu"
    }/* NODE: Loop 1346 */

#line 88 "../final/game.ceu"
    for (;;) {
/* NODE: Block 510 */

#line 89 "../final/game.ceu"
    {/* NODE: Stmts 509 */

#line 89 "../final/game.ceu"
    {/* NODE: Stmts 1376 */

#line 88 "../final/game.ceu"
    {/* NODE: Nothing 1350 */
/* NODE: Await 1343 */

#line 88 "../final/game.ceu"
    goto _CEU_NO_1343_; /* avoids "not used" warning */
_CEU_NO_1343_:;

#line 88 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_REDRAW;
_ceu_trl->lbl = Player_Awake_SDL_REDRAW_23;
_ceu_trl->seqno = _ceu_app->seqno;

#line 88 "../final/game.ceu"
    return;

case Player_Awake_SDL_REDRAW_23:;

#line 88 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1663 */
/* NODE: Nothing 1664 */

#line 88 "../final/game.ceu"
    }/* NODE: CallStmt 487 */

#line 89 "../final/game.ceu"
    SDL_SetRenderDrawColor((((*((CEU_Player*)_ceu_org)).ren)),0x00,0x00,0x00,0x00);/* NODE: Set 1377 */

#line 91 "../final/game.ceu"
/* SET: . *//* NODE: Op2_/ 492 */

#line 91 "../final/game.ceu"
    (((((CEU_Player*)_ceu_org)->r).x)) = ((((CEU_Player*)_ceu_org)->x)/1000);/* NODE: Set 1378 */

#line 92 "../final/game.ceu"
/* SET: . *//* NODE: Op2_/ 498 */

#line 92 "../final/game.ceu"
    (((((CEU_Player*)_ceu_org)->r).y)) = ((((CEU_Player*)_ceu_org)->y)/1000);/* NODE: CallStmt 508 */

#line 93 "../final/game.ceu"
    SDL_RenderFillRect((((*((CEU_Player*)_ceu_org)).ren)),(&((CEU_Player*)_ceu_org)->r));
#line 89 "../final/game.ceu"
    }
#line 89 "../final/game.ceu"
/* CLEAR: Block (89) */
#line 89 "../final/game.ceu"
    if (0) {

#line 89 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 88 "../final/game.ceu"
    }

#line 88 "../final/game.ceu"
    }
#line 88 "../final/game.ceu"
/* CLEAR: Block (88) */
#line 88 "../final/game.ceu"
    if (0) {

#line 88 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 88 "../final/game.ceu"
    }
#line 88 "../final/game.ceu"
/* CLEAR: Block (88) */
#line 88 "../final/game.ceu"
    if (0) {

#line 88 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 44 "../final/game.ceu"
case Player_ParEver_sub_2_7:;/* NODE: Block 475 */

#line 51 "../final/game.ceu"
    {/* NODE: Stmts 474 */

#line 51 "../final/game.ceu"
    {/* NODE: ParEver 473 */

#line 51 "../final/game.ceu"
/* ParEver: spawn subs */
#line 51 "../final/game.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 4, 1 };
#endif

#line 51 "../final/game.ceu"
        _ceu_org->trls[ 1 ].lbl = Player_ParEver_sub_1_11;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 51 "../final/game.ceu"
        _ceu_org->trls[ 2 ].lbl = Player_ParEver_sub_2_12;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 51 "../final/game.ceu"
        _ceu_org->trls[ 3 ].lbl = Player_ParEver_sub_3_13;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 3 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 51 "../final/game.ceu"
        _ceu_trl = &_ceu_org->trls[ 4 ];

#line 51 "../final/game.ceu"
    }
/* NODE: Block 472 */

#line 77 "../final/game.ceu"
    {/* NODE: Stmts 471 */

#line 77 "../final/game.ceu"
    {/* NODE: Block 1257 */

#line 77 "../final/game.ceu"
    {/* NODE: Stmts 1256 */

#line 77 "../final/game.ceu"
    {/* NODE: Stmts 1255 */

#line 77 "../final/game.ceu"
    {
#line 77 "../final/game.ceu"
    }/* NODE: Loop 1254 */

#line 77 "../final/game.ceu"
    for (;;) {
/* NODE: Block 469 */

#line 78 "../final/game.ceu"
    {/* NODE: Stmts 468 */

#line 78 "../final/game.ceu"
    {/* NODE: Stmts 1260 */

#line 78 "../final/game.ceu"
    {/* NODE: Dcl_var 1259 */

#line 78 "../final/game.ceu"
    }/* NODE: Stmts 1294 */

#line 79 "../final/game.ceu"
    {/* NODE: Nothing 1268 */
/* NODE: Block 1298 */

#line 79 "../final/game.ceu"
    {/* NODE: Stmts 1297 */

#line 79 "../final/game.ceu"
    {/* NODE: Stmts 1296 */

#line 79 "../final/game.ceu"
    {
#line 79 "../final/game.ceu"
    }/* NODE: Loop 1295 */

#line 79 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1266 */

#line 79 "../final/game.ceu"
    {/* NODE: Set 1262 */

#line 79 "../final/game.ceu"
/* SET: table: 0x7f962942fd50 *//* NODE: Await 442 */

#line 79 "../final/game.ceu"
    goto _CEU_NO_442_; /* avoids "not used" warning */
_CEU_NO_442_:;

#line 79 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYDOWN;
_ceu_trl->lbl = Player_Awake_SDL_KEYDOWN_21;
_ceu_trl->seqno = _ceu_app->seqno;

#line 79 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYDOWN_21:;

#line 79 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 79 "../final/game.ceu"
    {

#line 79 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 79 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_28) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1265 */

#line 79 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_28)).keysym)).sym))==SDLK_DOWN)) {
/* NODE: Break 1263 */

#line 79 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1264 */
}

#line 79 "../final/game.ceu"
    }
#line 79 "../final/game.ceu"
    }

#line 79 "../final/game.ceu"
/* CLEAR: Loop (79) */
#line 79 "../final/game.ceu"
    }
#line 79 "../final/game.ceu"
/* CLEAR: Block (79) */
#line 79 "../final/game.ceu"
    if (0) {

#line 79 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1659 */
/* NODE: Nothing 1660 */

#line 79 "../final/game.ceu"
    }/* NODE: Set 1301 */

#line 80 "../final/game.ceu"
/* SET: vy *//* NODE: Op2_+ 447 */

#line 80 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vy) = ((((CEU_Player*)_ceu_org)->vy)+100);/* NODE: Stmts 1335 */

#line 81 "../final/game.ceu"
    {/* NODE: Nothing 1309 */
/* NODE: Block 1339 */

#line 81 "../final/game.ceu"
    {/* NODE: Stmts 1338 */

#line 81 "../final/game.ceu"
    {/* NODE: Stmts 1337 */

#line 81 "../final/game.ceu"
    {
#line 81 "../final/game.ceu"
    }/* NODE: Loop 1336 */

#line 81 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1307 */

#line 81 "../final/game.ceu"
    {/* NODE: Set 1303 */

#line 81 "../final/game.ceu"
/* SET: table: 0x7f96294307f0 *//* NODE: Await 456 */

#line 81 "../final/game.ceu"
    goto _CEU_NO_456_; /* avoids "not used" warning */
_CEU_NO_456_:;

#line 81 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYUP;
_ceu_trl->lbl = Player_Awake_SDL_KEYUP_22;
_ceu_trl->seqno = _ceu_app->seqno;

#line 81 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYUP_22:;

#line 81 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 81 "../final/game.ceu"
    {

#line 81 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 81 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_28) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1306 */

#line 81 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_28)).keysym)).sym))==SDLK_DOWN)) {
/* NODE: Break 1304 */

#line 81 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1305 */
}

#line 81 "../final/game.ceu"
    }
#line 81 "../final/game.ceu"
    }

#line 81 "../final/game.ceu"
/* CLEAR: Loop (81) */
#line 81 "../final/game.ceu"
    }
#line 81 "../final/game.ceu"
/* CLEAR: Block (81) */
#line 81 "../final/game.ceu"
    if (0) {

#line 81 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1661 */
/* NODE: Nothing 1662 */

#line 81 "../final/game.ceu"
    }/* NODE: Set 1342 */

#line 82 "../final/game.ceu"
/* SET: vy *//* NODE: Op2_- 461 */

#line 82 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vy) = ((((CEU_Player*)_ceu_org)->vy)-100);/* NODE: CallStmt 467 */

#line 83 "../final/game.ceu"
    printf("baixo\n");
#line 78 "../final/game.ceu"
    }
#line 78 "../final/game.ceu"
/* CLEAR: Block (78) */
#line 78 "../final/game.ceu"
    if (0) {

#line 78 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 77 "../final/game.ceu"
    }

#line 77 "../final/game.ceu"
    }
#line 77 "../final/game.ceu"
/* CLEAR: Block (77) */
#line 77 "../final/game.ceu"
    if (0) {

#line 77 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 77 "../final/game.ceu"
    }
#line 77 "../final/game.ceu"
/* CLEAR: Block (77) */
#line 77 "../final/game.ceu"
    if (0) {

#line 77 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 51 "../final/game.ceu"
case Player_ParEver_sub_3_13:;/* NODE: Block 432 */

#line 68 "../final/game.ceu"
    {/* NODE: Stmts 431 */

#line 68 "../final/game.ceu"
    {/* NODE: Block 1168 */

#line 68 "../final/game.ceu"
    {/* NODE: Stmts 1167 */

#line 68 "../final/game.ceu"
    {/* NODE: Stmts 1166 */

#line 68 "../final/game.ceu"
    {
#line 68 "../final/game.ceu"
    }/* NODE: Loop 1165 */

#line 68 "../final/game.ceu"
    for (;;) {
/* NODE: Block 429 */

#line 69 "../final/game.ceu"
    {/* NODE: Stmts 428 */

#line 69 "../final/game.ceu"
    {/* NODE: Stmts 1171 */

#line 69 "../final/game.ceu"
    {/* NODE: Dcl_var 1170 */

#line 69 "../final/game.ceu"
    }/* NODE: Stmts 1205 */

#line 70 "../final/game.ceu"
    {/* NODE: Nothing 1179 */
/* NODE: Block 1209 */

#line 70 "../final/game.ceu"
    {/* NODE: Stmts 1208 */

#line 70 "../final/game.ceu"
    {/* NODE: Stmts 1207 */

#line 70 "../final/game.ceu"
    {
#line 70 "../final/game.ceu"
    }/* NODE: Loop 1206 */

#line 70 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1177 */

#line 70 "../final/game.ceu"
    {/* NODE: Set 1173 */

#line 70 "../final/game.ceu"
/* SET: table: 0x7f962942d1c0 *//* NODE: Await 400 */

#line 70 "../final/game.ceu"
    goto _CEU_NO_400_; /* avoids "not used" warning */
_CEU_NO_400_:;

#line 70 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYDOWN;
_ceu_trl->lbl = Player_Awake_SDL_KEYDOWN_19;
_ceu_trl->seqno = _ceu_app->seqno;

#line 70 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYDOWN_19:;

#line 70 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 70 "../final/game.ceu"
    {

#line 70 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 70 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_27) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1176 */

#line 70 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_27)).keysym)).sym))==SDLK_UP)) {
/* NODE: Break 1174 */

#line 70 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1175 */
}

#line 70 "../final/game.ceu"
    }
#line 70 "../final/game.ceu"
    }

#line 70 "../final/game.ceu"
/* CLEAR: Loop (70) */
#line 70 "../final/game.ceu"
    }
#line 70 "../final/game.ceu"
/* CLEAR: Block (70) */
#line 70 "../final/game.ceu"
    if (0) {

#line 70 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1655 */
/* NODE: Nothing 1656 */

#line 70 "../final/game.ceu"
    }/* NODE: Set 1212 */

#line 71 "../final/game.ceu"
/* SET: vy *//* NODE: Op2_- 405 */

#line 71 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vy) = ((((CEU_Player*)_ceu_org)->vy)-100);/* NODE: Stmts 1246 */

#line 72 "../final/game.ceu"
    {/* NODE: Nothing 1220 */
/* NODE: Block 1250 */

#line 72 "../final/game.ceu"
    {/* NODE: Stmts 1249 */

#line 72 "../final/game.ceu"
    {/* NODE: Stmts 1248 */

#line 72 "../final/game.ceu"
    {
#line 72 "../final/game.ceu"
    }/* NODE: Loop 1247 */

#line 72 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1218 */

#line 72 "../final/game.ceu"
    {/* NODE: Set 1214 */

#line 72 "../final/game.ceu"
/* SET: table: 0x7f962942dc60 *//* NODE: Await 414 */

#line 72 "../final/game.ceu"
    goto _CEU_NO_414_; /* avoids "not used" warning */
_CEU_NO_414_:;

#line 72 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYUP;
_ceu_trl->lbl = Player_Awake_SDL_KEYUP_20;
_ceu_trl->seqno = _ceu_app->seqno;

#line 72 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYUP_20:;

#line 72 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 72 "../final/game.ceu"
    {

#line 72 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 72 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_27) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1217 */

#line 72 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_27)).keysym)).sym))==SDLK_UP)) {
/* NODE: Break 1215 */

#line 72 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1216 */
}

#line 72 "../final/game.ceu"
    }
#line 72 "../final/game.ceu"
    }

#line 72 "../final/game.ceu"
/* CLEAR: Loop (72) */
#line 72 "../final/game.ceu"
    }
#line 72 "../final/game.ceu"
/* CLEAR: Block (72) */
#line 72 "../final/game.ceu"
    if (0) {

#line 72 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1657 */
/* NODE: Nothing 1658 */

#line 72 "../final/game.ceu"
    }/* NODE: Set 1253 */

#line 73 "../final/game.ceu"
/* SET: vy *//* NODE: Op2_+ 419 */

#line 73 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vy) = ((((CEU_Player*)_ceu_org)->vy)+100);/* NODE: CallStmt 427 */

#line 74 "../final/game.ceu"
    printf("fire %d %d\n",(((CEU_Player*)_ceu_org)->x),(((CEU_Player*)_ceu_org)->y));
#line 69 "../final/game.ceu"
    }
#line 69 "../final/game.ceu"
/* CLEAR: Block (69) */
#line 69 "../final/game.ceu"
    if (0) {

#line 69 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 68 "../final/game.ceu"
    }

#line 68 "../final/game.ceu"
    }
#line 68 "../final/game.ceu"
/* CLEAR: Block (68) */
#line 68 "../final/game.ceu"
    if (0) {

#line 68 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 68 "../final/game.ceu"
    }
#line 68 "../final/game.ceu"
/* CLEAR: Block (68) */
#line 68 "../final/game.ceu"
    if (0) {

#line 68 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 51 "../final/game.ceu"
case Player_ParEver_sub_2_12:;/* NODE: Block 390 */

#line 60 "../final/game.ceu"
    {/* NODE: Stmts 389 */

#line 60 "../final/game.ceu"
    {/* NODE: Block 1079 */

#line 60 "../final/game.ceu"
    {/* NODE: Stmts 1078 */

#line 60 "../final/game.ceu"
    {/* NODE: Stmts 1077 */

#line 60 "../final/game.ceu"
    {
#line 60 "../final/game.ceu"
    }/* NODE: Loop 1076 */

#line 60 "../final/game.ceu"
    for (;;) {
/* NODE: Block 387 */

#line 61 "../final/game.ceu"
    {/* NODE: Stmts 386 */

#line 61 "../final/game.ceu"
    {/* NODE: Stmts 1082 */

#line 61 "../final/game.ceu"
    {/* NODE: Dcl_var 1081 */

#line 61 "../final/game.ceu"
    }/* NODE: Stmts 1116 */

#line 62 "../final/game.ceu"
    {/* NODE: Nothing 1090 */
/* NODE: Block 1120 */

#line 62 "../final/game.ceu"
    {/* NODE: Stmts 1119 */

#line 62 "../final/game.ceu"
    {/* NODE: Stmts 1118 */

#line 62 "../final/game.ceu"
    {
#line 62 "../final/game.ceu"
    }/* NODE: Loop 1117 */

#line 62 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1088 */

#line 62 "../final/game.ceu"
    {/* NODE: Set 1084 */

#line 62 "../final/game.ceu"
/* SET: table: 0x7f962942ad30 *//* NODE: Await 365 */

#line 62 "../final/game.ceu"
    goto _CEU_NO_365_; /* avoids "not used" warning */
_CEU_NO_365_:;

#line 62 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYDOWN;
_ceu_trl->lbl = Player_Awake_SDL_KEYDOWN_17;
_ceu_trl->seqno = _ceu_app->seqno;

#line 62 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYDOWN_17:;

#line 62 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 62 "../final/game.ceu"
    {

#line 62 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 62 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_26) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1087 */

#line 62 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_26)).keysym)).sym))==SDLK_RIGHT)) {
/* NODE: Break 1085 */

#line 62 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1086 */
}

#line 62 "../final/game.ceu"
    }
#line 62 "../final/game.ceu"
    }

#line 62 "../final/game.ceu"
/* CLEAR: Loop (62) */
#line 62 "../final/game.ceu"
    }
#line 62 "../final/game.ceu"
/* CLEAR: Block (62) */
#line 62 "../final/game.ceu"
    if (0) {

#line 62 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1651 */
/* NODE: Nothing 1652 */

#line 62 "../final/game.ceu"
    }/* NODE: Set 1123 */

#line 63 "../final/game.ceu"
/* SET: vx *//* NODE: Op2_+ 370 */

#line 63 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vx) = (100+(((CEU_Player*)_ceu_org)->vx));/* NODE: Stmts 1157 */

#line 64 "../final/game.ceu"
    {/* NODE: Nothing 1131 */
/* NODE: Block 1161 */

#line 64 "../final/game.ceu"
    {/* NODE: Stmts 1160 */

#line 64 "../final/game.ceu"
    {/* NODE: Stmts 1159 */

#line 64 "../final/game.ceu"
    {
#line 64 "../final/game.ceu"
    }/* NODE: Loop 1158 */

#line 64 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1129 */

#line 64 "../final/game.ceu"
    {/* NODE: Set 1125 */

#line 64 "../final/game.ceu"
/* SET: table: 0x7f962942b7d0 *//* NODE: Await 379 */

#line 64 "../final/game.ceu"
    goto _CEU_NO_379_; /* avoids "not used" warning */
_CEU_NO_379_:;

#line 64 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYUP;
_ceu_trl->lbl = Player_Awake_SDL_KEYUP_18;
_ceu_trl->seqno = _ceu_app->seqno;

#line 64 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYUP_18:;

#line 64 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 64 "../final/game.ceu"
    {

#line 64 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 64 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_26) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1128 */

#line 64 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_26)).keysym)).sym))==SDLK_RIGHT)) {
/* NODE: Break 1126 */

#line 64 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1127 */
}

#line 64 "../final/game.ceu"
    }
#line 64 "../final/game.ceu"
    }

#line 64 "../final/game.ceu"
/* CLEAR: Loop (64) */
#line 64 "../final/game.ceu"
    }
#line 64 "../final/game.ceu"
/* CLEAR: Block (64) */
#line 64 "../final/game.ceu"
    if (0) {

#line 64 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1653 */
/* NODE: Nothing 1654 */

#line 64 "../final/game.ceu"
    }/* NODE: Set 1164 */

#line 65 "../final/game.ceu"
/* SET: vx *//* NODE: Op2_- 384 */

#line 65 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vx) = ((((CEU_Player*)_ceu_org)->vx)-100);
#line 61 "../final/game.ceu"
    }
#line 61 "../final/game.ceu"
/* CLEAR: Block (61) */
#line 61 "../final/game.ceu"
    if (0) {

#line 61 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 60 "../final/game.ceu"
    }

#line 60 "../final/game.ceu"
    }
#line 60 "../final/game.ceu"
/* CLEAR: Block (60) */
#line 60 "../final/game.ceu"
    if (0) {

#line 60 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 60 "../final/game.ceu"
    }
#line 60 "../final/game.ceu"
/* CLEAR: Block (60) */
#line 60 "../final/game.ceu"
    if (0) {

#line 60 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 51 "../final/game.ceu"
case Player_ParEver_sub_1_11:;/* NODE: Block 355 */

#line 52 "../final/game.ceu"
    {/* NODE: Stmts 354 */

#line 52 "../final/game.ceu"
    {/* NODE: Block 990 */

#line 52 "../final/game.ceu"
    {/* NODE: Stmts 989 */

#line 52 "../final/game.ceu"
    {/* NODE: Stmts 988 */

#line 52 "../final/game.ceu"
    {
#line 52 "../final/game.ceu"
    }/* NODE: Loop 987 */

#line 52 "../final/game.ceu"
    for (;;) {
/* NODE: Block 352 */

#line 53 "../final/game.ceu"
    {/* NODE: Stmts 351 */

#line 53 "../final/game.ceu"
    {/* NODE: Stmts 993 */

#line 53 "../final/game.ceu"
    {/* NODE: Dcl_var 992 */

#line 53 "../final/game.ceu"
    }/* NODE: Stmts 1027 */

#line 54 "../final/game.ceu"
    {/* NODE: Nothing 1001 */
/* NODE: Block 1031 */

#line 54 "../final/game.ceu"
    {/* NODE: Stmts 1030 */

#line 54 "../final/game.ceu"
    {/* NODE: Stmts 1029 */

#line 54 "../final/game.ceu"
    {
#line 54 "../final/game.ceu"
    }/* NODE: Loop 1028 */

#line 54 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 999 */

#line 54 "../final/game.ceu"
    {/* NODE: Set 995 */

#line 54 "../final/game.ceu"
/* SET: table: 0x7f9629428850 *//* NODE: Await 330 */

#line 54 "../final/game.ceu"
    goto _CEU_NO_330_; /* avoids "not used" warning */
_CEU_NO_330_:;

#line 54 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYDOWN;
_ceu_trl->lbl = Player_Awake_SDL_KEYDOWN_15;
_ceu_trl->seqno = _ceu_app->seqno;

#line 54 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYDOWN_15:;

#line 54 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 54 "../final/game.ceu"
    {

#line 54 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 54 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_25) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 998 */

#line 54 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_25)).keysym)).sym))==SDLK_LEFT)) {
/* NODE: Break 996 */

#line 54 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 997 */
}

#line 54 "../final/game.ceu"
    }
#line 54 "../final/game.ceu"
    }

#line 54 "../final/game.ceu"
/* CLEAR: Loop (54) */
#line 54 "../final/game.ceu"
    }
#line 54 "../final/game.ceu"
/* CLEAR: Block (54) */
#line 54 "../final/game.ceu"
    if (0) {

#line 54 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1647 */
/* NODE: Nothing 1648 */

#line 54 "../final/game.ceu"
    }/* NODE: Set 1034 */

#line 55 "../final/game.ceu"
/* SET: vx *//* NODE: Op2_- 335 */

#line 55 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vx) = ((((CEU_Player*)_ceu_org)->vx)-100);/* NODE: Stmts 1068 */

#line 56 "../final/game.ceu"
    {/* NODE: Nothing 1042 */
/* NODE: Block 1072 */

#line 56 "../final/game.ceu"
    {/* NODE: Stmts 1071 */

#line 56 "../final/game.ceu"
    {/* NODE: Stmts 1070 */

#line 56 "../final/game.ceu"
    {
#line 56 "../final/game.ceu"
    }/* NODE: Loop 1069 */

#line 56 "../final/game.ceu"
    for (;;) {
/* NODE: Stmts 1040 */

#line 56 "../final/game.ceu"
    {/* NODE: Set 1036 */

#line 56 "../final/game.ceu"
/* SET: table: 0x7f9629429340 *//* NODE: Await 344 */

#line 56 "../final/game.ceu"
    goto _CEU_NO_344_; /* avoids "not used" warning */
_CEU_NO_344_:;

#line 56 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_KEYUP;
_ceu_trl->lbl = Player_Awake_SDL_KEYUP_16;
_ceu_trl->seqno = _ceu_app->seqno;

#line 56 "../final/game.ceu"
    return;

case Player_Awake_SDL_KEYUP_16:;

#line 56 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 56 "../final/game.ceu"
    {

#line 56 "../final/game.ceu"
        tceu__SDL_KeyboardEvent_** __ceu_casted = (tceu__SDL_KeyboardEvent_**) _ceu_evt->param;

#line 56 "../final/game.ceu"
        {
        (((CEU_Player*)_ceu_org)->key_25) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: If 1039 */

#line 56 "../final/game.ceu"
    if (((((((*(((CEU_Player*)_ceu_org)->key_25)).keysym)).sym))==SDLK_LEFT)) {
/* NODE: Break 1037 */

#line 56 "../final/game.ceu"
    break;} else {
/* NODE: Nothing 1038 */
}

#line 56 "../final/game.ceu"
    }
#line 56 "../final/game.ceu"
    }

#line 56 "../final/game.ceu"
/* CLEAR: Loop (56) */
#line 56 "../final/game.ceu"
    }
#line 56 "../final/game.ceu"
/* CLEAR: Block (56) */
#line 56 "../final/game.ceu"
    if (0) {

#line 56 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Nothing 1649 */
/* NODE: Nothing 1650 */

#line 56 "../final/game.ceu"
    }/* NODE: Set 1075 */

#line 57 "../final/game.ceu"
/* SET: vx *//* NODE: Op2_+ 349 */

#line 57 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->vx) = ((((CEU_Player*)_ceu_org)->vx)+100);
#line 53 "../final/game.ceu"
    }
#line 53 "../final/game.ceu"
/* CLEAR: Block (53) */
#line 53 "../final/game.ceu"
    if (0) {

#line 53 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 52 "../final/game.ceu"
    }

#line 52 "../final/game.ceu"
    }
#line 52 "../final/game.ceu"
/* CLEAR: Block (52) */
#line 52 "../final/game.ceu"
    if (0) {

#line 52 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 52 "../final/game.ceu"
    }
#line 52 "../final/game.ceu"
/* CLEAR: Block (52) */
#line 52 "../final/game.ceu"
    if (0) {

#line 52 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 51 "../final/game.ceu"
    }
#line 51 "../final/game.ceu"
/* CLEAR: Block (51) */
#line 51 "../final/game.ceu"
    if (0) {

#line 51 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 44 "../final/game.ceu"
case Player_ParEver_sub_1_6:;/* NODE: Block 320 */

#line 45 "../final/game.ceu"
    {/* NODE: Stmts 319 */

#line 45 "../final/game.ceu"
    {/* NODE: Block 939 */

#line 45 "../final/game.ceu"
    {
#line 45 "../final/game.ceu"
    int __ceu_dt_24;
/* NODE: Stmts 938 */

#line 45 "../final/game.ceu"
    {/* NODE: Stmts 937 */

#line 45 "../final/game.ceu"
    {/* NODE: Dcl_var 1644 */

#line 45 "../final/game.ceu"
    }/* NODE: Loop 936 */

#line 45 "../final/game.ceu"
    for (;;) {
/* NODE: Block 317 */

#line 46 "../final/game.ceu"
    {/* NODE: Stmts 316 */

#line 46 "../final/game.ceu"
    {/* NODE: Stmts 980 */

#line 45 "../final/game.ceu"
    {/* NODE: Nothing 942 */
/* NODE: Set 941 */

#line 45 "../final/game.ceu"
/* SET: table: 0x7f9629427180 *//* NODE: Await 932 */

#line 45 "../final/game.ceu"
    goto _CEU_NO_932_; /* avoids "not used" warning */
_CEU_NO_932_:;

#line 45 "../final/game.ceu"
    _ceu_trl->evt = CEU_IN_SDL_DT;
_ceu_trl->lbl = Player_Awake_SDL_DT_10;
_ceu_trl->seqno = _ceu_app->seqno;

#line 45 "../final/game.ceu"
    return;

case Player_Awake_SDL_DT_10:;

#line 45 "../final/game.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 45 "../final/game.ceu"
    {

#line 45 "../final/game.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 45 "../final/game.ceu"
        {
        (__ceu_dt_24) = ((*(__ceu_casted))->_1);
    }
}
/* NODE: Nothing 1645 */
/* NODE: Nothing 1646 */

#line 45 "../final/game.ceu"
    }/* NODE: Set 985 */

#line 46 "../final/game.ceu"
/* SET: x *//* NODE: Op2_+ 307 */

#line 46 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->x) = ((((CEU_Player*)_ceu_org)->x)+((((CEU_Player*)_ceu_org)->vx)*(__ceu_dt_24)));/* NODE: Set 986 */

#line 47 "../final/game.ceu"
/* SET: y *//* NODE: Op2_+ 314 */

#line 47 "../final/game.ceu"
    (((CEU_Player*)_ceu_org)->y) = ((((CEU_Player*)_ceu_org)->y)+((((CEU_Player*)_ceu_org)->vy)*(__ceu_dt_24)));
#line 46 "../final/game.ceu"
    }
#line 46 "../final/game.ceu"
/* CLEAR: Block (46) */
#line 46 "../final/game.ceu"
    if (0) {

#line 46 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 45 "../final/game.ceu"
    }

#line 45 "../final/game.ceu"
    }
#line 45 "../final/game.ceu"
/* CLEAR: Block (45) */
#line 45 "../final/game.ceu"
    if (0) {

#line 45 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 45 "../final/game.ceu"
    }
#line 45 "../final/game.ceu"
/* CLEAR: Block (45) */
#line 45 "../final/game.ceu"
    if (0) {

#line 45 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 41 "../final/game.ceu"
    }
#line 41 "../final/game.ceu"
/* CLEAR: Block (41) */
#line 41 "../final/game.ceu"
    if (0) {

#line 41 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "../final/game.ceu"
    return;
#line 34 "../final/game.ceu"
case Player_Set_out_5:;
#line 34 "../final/game.ceu"
/* CLEAR: SetBlock (34) */
#line 34 "../final/game.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  7);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,6);
#endif
}

#line 34 "../final/game.ceu"
    }
#line 34 "../final/game.ceu"
/* CLEAR: Block (34) */
#line 34 "../final/game.ceu"
    if (0) {

#line 34 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "../final/game.ceu"
    }
#line 34 "../final/game.ceu"
/* CLEAR: Block (34) */
#line 34 "../final/game.ceu"
    if (0) {

#line 34 "../final/game.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "../final/game.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 34 "../final/game.ceu"
    return;
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    app->dont_emit_kill = 0;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_ORGS_NEWS_MALLOC
    app->tofree = NULL;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex_external, NULL);
    pthread_mutex_init(&app->threads_mutex_internal, NULL);
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex_external);
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex_internal);
#endif

    

#ifdef CEU_OS_APP
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
#endif

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org_init(app, app->data, CEU_NTRAILS, Class_Main,
                     0, 0,
                     NULL, 0);

#ifdef CEU_LUA
    ceu_luaL_newstate(app->lua);
    ceu_out_assert(app->lua != NULL);
    ceu_luaL_openlibs(app->lua);
    ceu_lua_atpanic(app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    app->data->trls[0].evt = CEU_IN__INIT;
    app->data->trls[0].seqno = 0;
    ceu_sys_go(app, CEU_IN__INIT, NULL);

    /* avoids "unused" warnings */
#ifdef CEU_IFCS
    __ceu_nothing(&_CEU_APP);
#endif
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
